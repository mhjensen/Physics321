<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="PHY321: Time-dependent Forces and Fourier Series">

<title>PHY321: Time-dependent Forces and Fourier Series</title>







<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .reveal .alert-text-small   { font-size: 80%;  }
    .reveal .alert-text-large   { font-size: 130%; }
    .reveal .alert-text-normal  { font-size: 90%;  }
    .reveal .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
             -webkit-border-radius: 14px; -moz-border-radius: 14px;
             border-radius:14px;
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .reveal .alert-block {padding-top:14px; padding-bottom:14px}
     .reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
     /*.reveal .alert li {margin-top: 1em}*/
     .reveal .alert-block p+p {margin-top:5px}
     /*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
     .reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
     .reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
     .reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body>
<div class="reveal">

<!-- Any section element inside the <div class="slides"> container
     is displayed as a slide -->

<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    



<section>
<!-- ------------------- main content ---------------------- -->



<center><h1 style="text-align: center;">PHY321: Time-dependent Forces and Fourier Series</h1></center>  <!-- document title -->

<p>
<!-- author(s): <a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a> -->

<center>
<b><a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a></b> [1, 2]
</center>

<p>&nbsp;<br>
<!-- institution(s) -->

<center>[1] <b>Department of Physics and Astronomy and Facility for Rare Ion Beams (FRIB), Michigan State University, USA</b></center>
<center>[2] <b>Department of Physics, University of Oslo, Norway</b></center>
<br>
<p>&nbsp;<br>
<center><h4>Mar 13, 2021</h4></center> <!-- date -->
<br>
<p>

<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2021, "Morten Hjorth-Jensen":"http://mhjgit.github.io/info/doc/web/". Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>


<section>
<h2 id="aims-and-overarching-motivation">Aims and Overarching Motivation </h2>

<p>
Driven oscillations and resonances with numerical examples.

<h3 id="monday">Monday </h3>

<p>
<b>Reading suggestion</b>: Taylor sections 5.6-5.8.

<h3 id="wednesday">Wednesday </h3>

Oscillations and resonances with examples like the mathematical pendulum.

<p>
<b>Reading suggestion</b>: Taylor chapter 5.

<h3 id="friday">Friday </h3>

<p>
Summary oscillations and first midterm and if we get time begin two-body problems.
We will drop the discussion on Fourier series.

<p>
<b>Reading suggestion</b>: Taylor section 8.2.
</section>


<section>
<h2 id="numerical-studies-of-driven-oscillations">Numerical Studies of Driven Oscillations </h2>

<p>
Solving the problem of driven oscillations numerically gives us much
more flexibility to study different types of driving forces. We can
reuse our earlier code by simply adding a driving force. If we stay in
the \( x \)-direction only this can be easily done by adding a term
\( F_{\mathrm{ext}}(x,t) \). Note that we have kept it rather general
here, allowing for both a spatial and a temporal dependence.

<p>
Before we dive into the code, we need to briefly remind ourselves
about the equations we started with for the case with damping, namely

<p>&nbsp;<br>
$$
m\frac{d^2x}{dt^2} + b\frac{dx}{dt}+kx(t) =0,
$$
<p>&nbsp;<br>

<p>
with no external force applied to the system.

<p>
Let us now for simplicty assume that our external force is given by

<p>&nbsp;<br>
$$
F_{\mathrm{ext}}(t) = F_0\cos{(\omega t)},
$$
<p>&nbsp;<br>

where \( F_0 \) is a constant (what is its dimension?) and \( \omega \) is the frequency of the applied external driving force.
<b>Small question:</b> would you expect energy to be conserved now?

<p>
Introducing the external force into our lovely differential equation
and dividing by \( m \) and introducing \( \omega_0^2=\sqrt{k/m} \) we have
<p>&nbsp;<br>
$$
\frac{d^2x}{dt^2} + \frac{b}{m}\frac{dx}{dt}+\omega_0^2x(t) =\frac{F_0}{m}\cos{(\omega t)},
$$
<p>&nbsp;<br>

<p>
Thereafter we introduce a dimensionless time \( \tau = t\omega_0 \)
and a dimensionless frequency \( \tilde{\omega}=\omega/\omega_0 \). We have then
<p>&nbsp;<br>
$$
\frac{d^2x}{d\tau^2} + \frac{b}{m\omega_0}\frac{dx}{d\tau}+x(\tau) =\frac{F_0}{m\omega_0^2}\cos{(\tilde{\omega}\tau)},
$$
<p>&nbsp;<br>

Introducing a new amplitude \( \tilde{F} =F_0/(m\omega_0^2) \) (check dimensionality again) we have
<p>&nbsp;<br>
$$
\frac{d^2x}{d\tau^2} + \frac{b}{m\omega_0}\frac{dx}{d\tau}+x(\tau) =\tilde{F}\cos{(\tilde{\omega}\tau)}.
$$
<p>&nbsp;<br>

<p>
Our final step, as we did in the case of various types of damping, is
to define \( \gamma = b/(2m\omega_0) \) and rewrite our equations as
<p>&nbsp;<br>
$$
\frac{d^2x}{d\tau^2} + 2\gamma\frac{dx}{d\tau}+x(\tau) =\tilde{F}\cos{(\tilde{\omega}\tau)}.
$$
<p>&nbsp;<br>

This is the equation we will code below using the Euler-Cromer method.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)


<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">pylab</span> <span style="color: #8B008B; font-weight: bold">import</span> plt, mpl
plt.style.use(<span style="color: #CD5555">&#39;seaborn&#39;</span>)
mpl.rcParams[<span style="color: #CD5555">&#39;font.family&#39;</span>] = <span style="color: #CD5555">&#39;serif&#39;</span>


DeltaT = <span style="color: #B452CD">0.001</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">20</span> <span style="color: #228B22"># in dimensionless time</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v, and x</span>
t = np.zeros(n)
v = np.zeros(n)
x = np.zeros(n)
<span style="color: #228B22"># Initial conditions as one-dimensional arrays of time</span>
x0 =  <span style="color: #B452CD">1.0</span> 
v0 = <span style="color: #B452CD">0.0</span>
x[<span style="color: #B452CD">0</span>] = x0
v[<span style="color: #B452CD">0</span>] = v0
gamma = <span style="color: #B452CD">0.2</span>
Omegatilde = <span style="color: #B452CD">0.5</span>
Ftilde = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Start integrating using Euler-Cromer&#39;s method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up the acceleration</span>
    <span style="color: #228B22"># Here you could have defined your own function for this</span>
    a =  -<span style="color: #B452CD">2</span>*gamma*v[i]-x[i]+Ftilde*cos(t[i]*Omegatilde)
    <span style="color: #228B22"># update velocity, time and position</span>
    v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*a
    x[i+<span style="color: #B452CD">1</span>] = x[i] + DeltaT*v[i+<span style="color: #B452CD">1</span>]
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
<span style="color: #228B22"># Plot position as function of time    </span>
fig, ax = plt.subplots()
ax.set_ylabel(<span style="color: #CD5555">&#39;x[m]&#39;</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;t[s]&#39;</span>)
ax.plot(t, x)
fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;ForcedBlockEulerCromer&quot;</span>)
plt.show()
</pre></div>
<p>
In the above example we have focused on the Euler-Cromer method. This
method has a local truncation error which is proportional to \( \Delta t^2 \)
and thereby a global error which is proportional to \( \Delta t \).
We can improve this by using the Runge-Kutta family of
methods. The widely popular Runge-Kutta to fourth order or just <b>RK4</b>
has indeed a much better truncation error. The RK4 method has a global
error which is proportional to \( \Delta t \).

<p>
Let us revisit this method and see how we can implement it for the above example.
</section>


<section>
<h2 id="differential-equations-runge-kutta-methods">Differential Equations, Runge-Kutta methods </h2>

<p>
Runge-Kutta (RK) methods are based on Taylor expansion formulae, but yield
in general better algorithms for solutions of an ordinary differential equation.
The basic philosophy is that it provides an intermediate step in the computation of \( y_{i+1} \).

<p>
To see this, consider first the following definitions
<p>&nbsp;<br>
$$
\begin{equation}
\frac{dy}{dt}=f(t,y),  
\tag{1}
\end{equation} 
$$
<p>&nbsp;<br>

and 
<p>&nbsp;<br>
$$
\begin{equation}
y(t)=\int f(t,y) dt,  
\tag{2}
\end{equation} 
$$
<p>&nbsp;<br>

and 
<p>&nbsp;<br>
$$
\begin{equation}
y_{i+1}=y_i+ \int_{t_i}^{t_{i+1}} f(t,y) dt.
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>

<p>
To demonstrate the philosophy behind RK methods, let us consider
the second-order RK method, RK2.
The first approximation consists in Taylor expanding \( f(t,y) \)
around the center of the integration interval \( t_i \) to \( t_{i+1} \),
that is, at \( t_i+h/2 \), \( h \) being the step.
Using the midpoint formula for an integral, 
defining \( y(t_i+h/2) = y_{i+1/2} \) and   
\( t_i+h/2 = t_{i+1/2} \), we obtain
<p>&nbsp;<br>
$$
\begin{equation}
\int_{t_i}^{t_{i+1}} f(t,y) dt \approx hf(t_{i+1/2},y_{i+1/2}) +O(h^3).
\tag{4}
\end{equation} 
$$
<p>&nbsp;<br>

This means in turn that we have
<p>&nbsp;<br>
$$
\begin{equation}
y_{i+1}=y_i + hf(t_{i+1/2},y_{i+1/2}) +O(h^3).
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>

<p>
However, we do not know the value of   \( y_{i+1/2} \). Here comes thus the next approximation, namely, we use Euler's
method to approximate \( y_{i+1/2} \). We have then
<p>&nbsp;<br>
$$
\begin{equation}
y_{(i+1/2)}=y_i + \frac{h}{2}\frac{dy}{dt}=y(t_i) + \frac{h}{2}f(t_i,y_i).
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>

This means that we can define the following algorithm for 
the second-order Runge-Kutta method, RK2.

<p>&nbsp;<br>
$$
\begin{equation} 
k_1=hf(t_i,y_i),
\tag{7}
\end{equation} 
$$
<p>&nbsp;<br>

<p>
and

<p>&nbsp;<br>
$$
\begin{equation}
k_2=hf(t_{i+1/2},y_i+k_1/2),
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>

<p>
with the final value

<p>&nbsp;<br>
$$
\begin{equation} 
y_{i+i}\approx y_i + k_2 +O(h^3). 
\tag{9}
\end{equation}
$$
<p>&nbsp;<br>

<p>
The difference between the previous one-step methods 
is that we now need an intermediate step in our evaluation,
namely \( t_i+h/2 = t_{(i+1/2)} \) where we evaluate the derivative \( f \). 
This involves more operations, but the gain is a better stability
in the solution.

<p>
The fourth-order Runge-Kutta, RK4, has the following algorithm

<p>&nbsp;<br>
$$
k_1=hf(t_i,y_i) \hspace{0.5cm}   k_2=hf(t_i+h/2,y_i+k_1/2)
$$
<p>&nbsp;<br>

<p>
and

<p>&nbsp;<br>
$$
k_3=hf(t_i+h/2,y_i+k_2/2)\hspace{0.5cm}   k_4=hf(t_i+h,y_i+k_3)
$$
<p>&nbsp;<br>

<p>
with the final result

<p>&nbsp;<br>
$$
y_{i+1}=y_i +\frac{1}{6}\left( k_1 +2k_2+2k_3+k_4\right).
$$
<p>&nbsp;<br>

<p>
Thus, the algorithm consists in first calculating \( k_1 \) 
with \( t_i \), \( y_1 \) and \( f \) as inputs. Thereafter, we increase the step
size by \( h/2 \) and calculate \( k_2 \), then \( k_3 \) and finally \( k_4 \). The global error goes as \( O(h^4) \).

<p>
However, at this stage, if we keep adding different methods in our
main program, the code will quickly become messy and ugly. Before we
proceed thus, we will now introduce functions that enbody the various
methods for solving differential equations. This means that we can
separate out these methods in own functions and files (and later as classes and more
generic functions) and simply call them when needed. Similarly, we
could easily encapsulate various forces or other quantities of
interest in terms of functions. To see this, let us bring up the code
we developed above for the simple sliding block, but now only with the simple forward Euler method. We introduce
two functions, one for the simple Euler method and one for the
force.

<p>
Note that here the forward Euler method does not know the specific force function to be called.
It receives just an input the name. We can easily change the force by adding another function.
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ForwardEuler</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
        v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*Force(v[i],x[i],t[i])
        x[i+<span style="color: #B452CD">1</span>] = x[i] + DeltaT*v[i]
        t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">SpringForce</span>(v,x,t):
<span style="color: #228B22">#   note here that we have divided by mass and we return the acceleration</span>
    <span style="color: #8B008B; font-weight: bold">return</span>  -<span style="color: #B452CD">2</span>*gamma*v-x+Ftilde*cos(t*Omegatilde)
</pre></div>
<p>
It is easy to add a new method like the Euler-Cromer
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ForwardEulerCromer</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
        a = Force(v[i],x[i],t[i])
        v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*a
        x[i+<span style="color: #B452CD">1</span>] = x[i] + DeltaT*v[i+<span style="color: #B452CD">1</span>]
        t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
</pre></div>
<p>
and the Velocity Verlet method (be careful with time-dependence here, it is not an ideal method for non-conservative forces))
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">VelocityVerlet</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
        a = Force(v[i],x[i],t[i])
        x[i+<span style="color: #B452CD">1</span>] = x[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*a*DeltaT*DeltaT
        anew = Force(v[i],x[i+<span style="color: #B452CD">1</span>],t[i+<span style="color: #B452CD">1</span>])
        v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
        t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
</pre></div>
<p>
Finally, we can now add the Runge-Kutta2 method via a new function
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">RK2</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
<span style="color: #228B22"># Setting up k1</span>
        k1x = DeltaT*v[i]
        k1v = DeltaT*Force(v[i],x[i],t[i])
<span style="color: #228B22"># Setting up k2</span>
        vv = v[i]+k1v*<span style="color: #B452CD">0.5</span>
        xx = x[i]+k1x*<span style="color: #B452CD">0.5</span>
        k2x = DeltaT*vv
        k2v = DeltaT*Force(vv,xx,t[i]+DeltaT*<span style="color: #B452CD">0.5</span>)
<span style="color: #228B22"># Final result</span>
        x[i+<span style="color: #B452CD">1</span>] = x[i]+k2x
        v[i+<span style="color: #B452CD">1</span>] = v[i]+k2v
	t[i+<span style="color: #B452CD">1</span>] = t[i]+DeltaT
</pre></div>
<p>
Finally, we can now add the Runge-Kutta2 method via a new function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">RK4</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
<span style="color: #228B22"># Setting up k1</span>
        k1x = DeltaT*v[i]
        k1v = DeltaT*Force(v[i],x[i],t[i])
<span style="color: #228B22"># Setting up k2</span>
        vv = v[i]+k1v*<span style="color: #B452CD">0.5</span>
        xx = x[i]+k1x*<span style="color: #B452CD">0.5</span>
        k2x = DeltaT*vv
        k2v = DeltaT*Force(vv,xx,t[i]+DeltaT*<span style="color: #B452CD">0.5</span>)
<span style="color: #228B22"># Setting up k3</span>
        vv = v[i]+k2v*<span style="color: #B452CD">0.5</span>
        xx = x[i]+k2x*<span style="color: #B452CD">0.5</span>
        k3x = DeltaT*vv
        k3v = DeltaT*Force(vv,xx,t[i]+DeltaT*<span style="color: #B452CD">0.5</span>)
<span style="color: #228B22"># Setting up k4</span>
        vv = v[i]+k3v
        xx = x[i]+k3x
        k4x = DeltaT*vv
        k4v = DeltaT*Force(vv,xx,t[i]+DeltaT)
<span style="color: #228B22"># Final result</span>
        x[i+<span style="color: #B452CD">1</span>] = x[i]+(k1x+<span style="color: #B452CD">2</span>*k2x+<span style="color: #B452CD">2</span>*k3x+k4x)/<span style="color: #B452CD">6.</span>
        v[i+<span style="color: #B452CD">1</span>] = v[i]+(k1v+<span style="color: #B452CD">2</span>*k2v+<span style="color: #B452CD">2</span>*k3v+k4v)/<span style="color: #B452CD">6.</span>
        t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
</pre></div>
<p>
The Runge-Kutta family of methods are particularly useful when we have a time-dependent acceleration.
If we have forces which depend only the spatial degrees of freedom (no velocity and/or time-dependence), then energy conserving methods like the Velocity Verlet or the Euler-Cromer method are preferred. As soon as we introduce an explicit time-dependence and/or add dissipitave forces like friction or air resistance, then methods like the family of Runge-Kutta methods are well suited for this. 
The code below uses the Runge-Kutta4 methods.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span>DeltaT = <span style="color: #B452CD">0.001</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">20</span> <span style="color: #228B22"># in dimensionless time</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v, and x</span>
t = np.zeros(n)
v = np.zeros(n)
x = np.zeros(n)
<span style="color: #228B22"># Initial conditions (can change to more than one dim)</span>
x0 =  <span style="color: #B452CD">1.0</span> 
v0 = <span style="color: #B452CD">0.0</span>
x[<span style="color: #B452CD">0</span>] = x0
v[<span style="color: #B452CD">0</span>] = v0
gamma = <span style="color: #B452CD">0.2</span>
Omegatilde = <span style="color: #B452CD">0.5</span>
Ftilde = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Start integrating using the RK4 method</span>
<span style="color: #228B22"># Note that we define the force function as a SpringForce</span>
RK4(v,x,t,n,SpringForce)

<span style="color: #228B22"># Plot position as function of time    </span>
fig, ax = plt.subplots()
ax.set_ylabel(<span style="color: #CD5555">&#39;x[m]&#39;</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;t[s]&#39;</span>)
ax.plot(t, x)
fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;ForcedBlockRK4&quot;</span>)
plt.show()
</pre></div>
</section>


<section>
<h2 id="example-the-classical-pendulum-and-scaling-the-equations">Example: The classical pendulum and scaling the equations </h2>

<p>
Let us end our discussion of oscillations with another classical case, the pendulum.

<p>
The angular equation of motion of the pendulum is given by
Newton's equation and with no external force it reads 
<p>&nbsp;<br>
$$
\begin{equation}
  ml\frac{d^2\theta}{dt^2}+mgsin(\theta)=0,
\tag{10}
\end{equation}
$$
<p>&nbsp;<br>

with an angular velocity and acceleration given by
<p>&nbsp;<br>
$$
\begin{equation}
     v=l\frac{d\theta}{dt},
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>

and 
<p>&nbsp;<br>
$$
\begin{equation}
     a=l\frac{d^2\theta}{dt^2}.
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>

<p>
We do however expect that the motion will gradually come to an end due a viscous drag torque acting on the pendulum. 
In the presence of the drag, the above equation becomes
<p>&nbsp;<br>
$$
\begin{equation}
   ml\frac{d^2\theta}{dt^2}+\nu\frac{d\theta}{dt}  +mgsin(\theta)=0, \tag{13}
\end{equation}
$$
<p>&nbsp;<br>

where \( \nu \) is now a positive constant parameterizing the viscosity
of the medium in question. In order to maintain the motion against
viscosity, it is necessary to add some external driving force. 
We choose here a periodic driving force. The last equation becomes then
<p>&nbsp;<br>
$$
\begin{equation}
   ml\frac{d^2\theta}{dt^2}+\nu\frac{d\theta}{dt}  +mgsin(\theta)=Asin(\omega t), \tag{14}
\end{equation}
$$
<p>&nbsp;<br>

with \( A \) and \( \omega \) two constants representing the amplitude and 
the angular frequency respectively. The latter is called the driving frequency.

<p>
We define 
<p>&nbsp;<br>
$$
      \omega_0=\sqrt{g/l},
  $$
<p>&nbsp;<br>

the so-called natural frequency and the new dimensionless quantities
<p>&nbsp;<br>
$$
      \hat{t}=\omega_0t,
  $$
<p>&nbsp;<br>

with the dimensionless driving frequency
<p>&nbsp;<br>
$$
     \hat{\omega}=\frac{\omega}{\omega_0},
  $$
<p>&nbsp;<br>

and introducing the quantity \( Q \), called the <em>quality factor</em>,
<p>&nbsp;<br>
$$
     Q=\frac{mg}{\omega_0\nu},
  $$
<p>&nbsp;<br>

  and the dimensionless amplitude 
<p>&nbsp;<br>
$$
\hat{A}=\frac{A}{mg}
  $$
<p>&nbsp;<br>
</section>


<section>
<h2 id="more-on-the-pendulum">More on the Pendulum </h2>

<p>
We have 
<p>&nbsp;<br>
$$
    \frac{d^2\theta}{d\hat{t}^2}+\frac{1}{Q}\frac{d\theta}{d\hat{t}}  
     +sin(\theta)=\hat{A}cos(\hat{\omega}\hat{t}).
$$
<p>&nbsp;<br>

This equation can in turn be recast in terms of two coupled first-order differential equations as follows
<p>&nbsp;<br>
$$
     \frac{d\theta}{d\hat{t}}=\hat{v},
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
     \frac{d\hat{v}}{d\hat{t}}=-\frac{\hat{v}}{Q}-sin(\theta)+\hat{A}cos(\hat{\omega}\hat{t}).
$$
<p>&nbsp;<br>

<p>
These are the equations to be solved.  The factor \( Q \) represents the
number of oscillations of the undriven system that must occur before
its energy is significantly reduced due to the viscous drag. The
amplitude \( \hat{A} \) is measured in units of the maximum possible
gravitational torque while \( \hat{\omega} \) is the angular frequency of
the external torque measured in units of the pendulum's natural
frequency.
</section>


<section>
<h2 id="the-pendulum-code">The Pendulum code </h2>

<p>
We need to define a new force, which we simply call the pendulum force. The only thing which changes from our previous spring-force problem is the non-linearity introduced by angle \( \theta \)  due to the \( \sin{\theta} \) term.  Here we have kept a generic variable \( x \) instead. This makes our codes very similar.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">PendulumForce</span>(v,x,t):
<span style="color: #228B22">#   note here that we have divided by mass and we return the acceleration</span>
    <span style="color: #8B008B; font-weight: bold">return</span>  -gamma*v-sin(x)+Ftilde*cos(t*Omegatilde)
</pre></div>
</section>


<section>
<h2 id="setting-up-the-various-variables-and-running-the-code">Setting up the various variables and running the code </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span>DeltaT = <span style="color: #B452CD">0.001</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">20</span> <span style="color: #228B22"># in years</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v, and x</span>
t = np.zeros(n)
v = np.zeros(n)
theta = np.zeros(n)
<span style="color: #228B22"># Initial conditions (can change to more than one dim)</span>
theta0 =  <span style="color: #B452CD">1.0</span> 
v0 = <span style="color: #B452CD">0.0</span>
theta[<span style="color: #B452CD">0</span>] = theta0
v[<span style="color: #B452CD">0</span>] = v0
gamma = <span style="color: #B452CD">0.2</span>
Omegatilde = <span style="color: #B452CD">0.5</span>
Ftilde = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Start integrating using the RK4 method</span>
<span style="color: #228B22"># Note that we define the force function as a PendulumForce</span>
RK4(v,theta,t,n,PendulumForce)

<span style="color: #228B22"># Plot position as function of time    </span>
fig, ax = plt.subplots()
ax.set_ylabel(<span style="color: #CD5555">&#39;theta[radians]&#39;</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;t[s]&#39;</span>)
ax.plot(t, theta)
fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;PendulumRK4&quot;</span>)
plt.show()
</pre></div>
</section>


<section>
<h2 id="principle-of-superposition-and-periodic-forces-fourier-transforms">Principle of Superposition and Periodic Forces (Fourier Transforms) </h2>

<p>
If one has several driving forces, \( F(t)=\sum_n F_n(t) \), one can find
the particular solution to each \( F_n \), \( x_{pn}(t) \), and the particular
solution for the entire driving force is

<p>&nbsp;<br>
$$
\begin{equation}
x_p(t)=\sum_nx_{pn}(t).
\tag{15}
\end{equation}
$$
<p>&nbsp;<br>

<p>
This is known as the principal of superposition. It only applies when
the homogenous equation is linear. If there were an anharmonic term
such as \( x^3 \) in the homogenous equation, then when one summed various
solutions, \( x=(\sum_n x_n)^2 \), one would get cross
terms. Superposition is especially useful when \( F(t) \) can be written
as a sum of sinusoidal terms, because the solutions for each
sinusoidal (sine or cosine)  term is analytic, as we saw above.

<p>
Driving forces are often periodic, even when they are not
sinusoidal. Periodicity implies that for some time \( \tau \)

<p>&nbsp;<br>
$$
\begin{eqnarray}
F(t+\tau)=F(t). 
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
One example of a non-sinusoidal periodic force is a square wave. Many
components in electric circuits are non-linear, e.g. diodes, which
makes many wave forms non-sinusoidal even when the circuits are being
driven by purely sinusoidal sources.

<p>
The code here shows a typical example of such a square wave generated using the functionality included in the <b>scipy</b> Python package. We have used a period of \( \tau=0.2 \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scipy</span> <span style="color: #8B008B; font-weight: bold">import</span> signal
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #228B22"># number of points                                                                                       </span>
n = <span style="color: #B452CD">500</span>
<span style="color: #228B22"># start and final times                                                                                  </span>
t0 = <span style="color: #B452CD">0.0</span>
tn = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Period                                                                                                 </span>
t = np.linspace(t0, tn, n, endpoint=<span style="color: #8B008B; font-weight: bold">False</span>)
SqrSignal = np.zeros(n)
SqrSignal = <span style="color: #B452CD">1.0</span>+signal.square(<span style="color: #B452CD">2</span>*np.pi*<span style="color: #B452CD">5</span>*t)
plt.plot(t, SqrSignal)
plt.ylim(-<span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">2.5</span>)
plt.show()
</pre></div>
<p>
For the sinusoidal example studied in the previous week the
period is \( \tau=2\pi/\omega \). However, higher harmonics can also
satisfy the periodicity requirement. In general, any force that
satisfies the periodicity requirement can be expressed as a sum over
harmonics,

<p>&nbsp;<br>
$$
\begin{equation}
F(t)=\frac{f_0}{2}+\sum_{n>0} f_n\cos(2n\pi t/\tau)+g_n\sin(2n\pi t/\tau).
\tag{16}
\end{equation}
$$
<p>&nbsp;<br>

<p>
We can write down the answer for
\( x_{pn}(t) \), by substituting \( f_n/m \) or \( g_n/m \) for \( F_0/m \). By
writing each factor \( 2n\pi t/\tau \) as \( n\omega t \), with \( \omega\equiv
2\pi/\tau \),

<p>&nbsp;<br>
$$
\begin{equation}
\tag{17}
F(t)=\frac{f_0}{2}+\sum_{n>0}f_n\cos(n\omega t)+g_n\sin(n\omega t).
\end{equation}
$$
<p>&nbsp;<br>

<p>
The solutions for \( x(t) \) then come from replacing \( \omega \) with
\( n\omega \) for each term in the particular solution,

<p>&nbsp;<br>
$$
\begin{eqnarray}
x_p(t)&=&\frac{f_0}{2k}+\sum_{n>0} \alpha_n\cos(n\omega t-\delta_n)+\beta_n\sin(n\omega t-\delta_n),\\
\nonumber
\alpha_n&=&\frac{f_n/m}{\sqrt{((n\omega)^2-\omega_0^2)+4\beta^2n^2\omega^2}},\\
\nonumber
\beta_n&=&\frac{g_n/m}{\sqrt{((n\omega)^2-\omega_0^2)+4\beta^2n^2\omega^2}},\\
\nonumber
\delta_n&=&\tan^{-1}\left(\frac{2\beta n\omega}{\omega_0^2-n^2\omega^2}\right).
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
Because the forces have been applied for a long time, any non-zero
damping eliminates the homogenous parts of the solution, so one need
only consider the particular solution for each \( n \).

<p>
The problem will considered solved if one can find expressions for the
coefficients \( f_n \) and \( g_n \), even though the solutions are expressed
as an infinite sum. The coefficients can be extracted from the
function \( F(t) \) by

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tag{18}
f_n&=&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2} dt~F(t)\cos(2n\pi t/\tau),\\
\nonumber
g_n&=&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2} dt~F(t)\sin(2n\pi t/\tau).
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
To check the consistency of these expressions and to verify
Eq. <a href="#mjx-eqn-18">(18)</a>, one can insert the expansion of \( F(t) \) in
Eq. <a href="#mjx-eqn-17">(17)</a> into the expression for the coefficients in
Eq. <a href="#mjx-eqn-18">(18)</a> and see whether

<p>&nbsp;<br>
$$
\begin{eqnarray}
f_n&=?&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2} dt~\left\{
\frac{f_0}{2}+\sum_{m>0}f_m\cos(m\omega t)+g_m\sin(m\omega t)
\right\}\cos(n\omega t).
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
Immediately, one can throw away all the terms with \( g_m \) because they
convolute an even and an odd function. The term with \( f_0/2 \)
disappears because \( \cos(n\omega t) \) is equally positive and negative
over the interval and will integrate to zero. For all the terms
\( f_m\cos(m\omega t) \) appearing in the sum, one can use angle addition
formulas to see that \( \cos(m\omega t)\cos(n\omega
t)=(1/2)(\cos[(m+n)\omega t]+\cos[(m-n)\omega t] \). This will integrate
to zero unless \( m=n \). In that case the \( m=n \) term gives

<p>&nbsp;<br>
$$
\begin{equation}
\int_{-\tau/2}^{\tau/2}dt~\cos^2(m\omega t)=\frac{\tau}{2},
\tag{19}
\end{equation}
$$
<p>&nbsp;<br>

<p>
and

<p>&nbsp;<br>
$$
\begin{eqnarray}
f_n&=?&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2} dt~f_n/2\\
\nonumber
&=&f_n~\checkmark.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
The same method can be used to check for the consistency of \( g_n \).

<p>
Consider the driving force:

<p>&nbsp;<br>
$$
\begin{equation}
F(t)=At/\tau,~~-\tau/2 < t < \tau/2,~~~F(t+\tau)=F(t).
\tag{20}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Find the Fourier coefficients \( f_n \) and \( g_n \) for all \( n \) using Eq. <a href="#mjx-eqn-18">(18)</a>.

<p>
Only the odd coefficients enter by symmetry, i.e. \( f_n=0 \). One can find \( g_n \) integrating by parts,

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tag{21}
g_n&=&\frac{2}{\tau}\int_{-\tau/2}^{\tau/2}dt~\sin(n\omega t) \frac{At}{\tau}\\
\nonumber
u&=&t,~dv=\sin(n\omega t)dt,~v=-\cos(n\omega t)/(n\omega),\\
\nonumber
g_n&=&\frac{-2A}{n\omega \tau^2}\int_{-\tau/2}^{\tau/2}dt~\cos(n\omega t)
+\left.2A\frac{-t\cos(n\omega t)}{n\omega\tau^2}\right|_{-\tau/2}^{\tau/2}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
The first term is zero because \( \cos(n\omega t) \) will be equally
positive and negative over the interval. Using the fact that
\( \omega\tau=2\pi \),

<p>&nbsp;<br>
$$
\begin{eqnarray}
g_n&=&-\frac{2A}{2n\pi}\cos(n\omega\tau/2)\\
\nonumber
&=&-\frac{A}{n\pi}\cos(n\pi)\\
\nonumber
&=&\frac{A}{n\pi}(-1)^{n+1}.
\end{eqnarray}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="fourier-series">Fourier Series </h2>

<p>
More text will come here, chpater 5.7-5.8 of Taylor are discussed
during the lectures. The code here uses the Fourier series discussed
in chapter 5.7 for a square wave signal. The equations for the
coefficients are are discussed in Taylor section 5.7, see Example
5.4. The code here visualizes the various approximations given by
Fourier series compared with a square wave with period \( T=0.2 \), witth
\( 0.1 \) and max value \( F=2 \). We see that when we increase the number of
components in the Fourier series, the Fourier series approximation gets closes and closes to the square wave signal.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scipy</span> <span style="color: #8B008B; font-weight: bold">import</span> signal
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #228B22"># number of points                                                                                       </span>
n = <span style="color: #B452CD">500</span>
<span style="color: #228B22"># start and final times                                                                                  </span>
t0 = <span style="color: #B452CD">0.0</span>
tn = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Period                                                                                                 </span>
T =<span style="color: #B452CD">0.2</span>
<span style="color: #228B22"># Max value of square signal                                                                             </span>
Fmax= <span style="color: #B452CD">2.0</span>
<span style="color: #228B22"># Width of signal                                                                                        </span>
Width = <span style="color: #B452CD">0.1</span>
t = np.linspace(t0, tn, n, endpoint=<span style="color: #8B008B; font-weight: bold">False</span>)
SqrSignal = np.zeros(n)
FourierSeriesSignal = np.zeros(n)
SqrSignal = <span style="color: #B452CD">1.0</span>+signal.square(<span style="color: #B452CD">2</span>*np.pi*<span style="color: #B452CD">5</span>*t+np.pi*Width/T)
a0 = Fmax*Width/T
FourierSeriesSignal = a0
Factor = <span style="color: #B452CD">2.0</span>*Fmax/np.pi
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,<span style="color: #B452CD">500</span>):
    FourierSeriesSignal += Factor/(i)*np.sin(np.pi*i*Width/T)*np.cos(i*t*<span style="color: #B452CD">2</span>*np.pi/T)
plt.plot(t, SqrSignal)
plt.plot(t, FourierSeriesSignal)
plt.ylim(-<span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">2.5</span>)
plt.show()
</pre></div>
</section>


<section>
<h2 id="solving-differential-equations-with-fouries-series">Solving differential equations with Fouries series </h2>

<p>
Material to be added.
</section>


<section>
<h2 id="response-to-transient-force">Response to Transient Force </h2>

<p>
Consider a particle at rest in the bottom of an underdamped harmonic
oscillator, that then feels a sudden impulse, or change in momentum,
\( I=F\Delta t \) at \( t=0 \). This increases the velocity immediately by an
amount \( v_0=I/m \) while not changing the position. One can then solve
the trajectory by solving the equations with initial
conditions \( v_0=I/m \) and \( x_0=0 \). This gives

<p>&nbsp;<br>
$$
\begin{equation}
x(t)=\frac{I}{m\omega'}e^{-\beta t}\sin\omega't, ~~t>0.
\tag{22}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Here, \( \omega'=\sqrt{\omega_0^2-\beta^2} \). For an impulse \( I_i \) that
occurs at time \( t_i \) the trajectory would be

<p>&nbsp;<br>
$$
\begin{equation}
x(t)=\frac{I_i}{m\omega'}e^{-\beta (t-t_i)}\sin[\omega'(t-t_i)] \Theta(t-t_i),
\tag{23}
\end{equation}
$$
<p>&nbsp;<br>

<p>
where \( \Theta(t-t_i) \) is a step function, i.e. \( \Theta(x) \) is zero for
\( x < 0 \) and unity for \( x>0 \). If there were several impulses linear
superposition tells us that we can sum over each contribution,

<p>&nbsp;<br>
$$
\begin{equation}
x(t)=\sum_i\frac{I_i}{m\omega'}e^{-\beta(t-t_i)}\sin[\omega'(t-t_i)]\Theta(t-t_i)
\tag{24}
\end{equation} 
$$
<p>&nbsp;<br>

<p>
Now one can consider a series of impulses at times separated by
\( \Delta t \), where each impulse is given by \( F_i\Delta t \). The sum
above now becomes an integral,

<p>&nbsp;<br>
$$
\begin{eqnarray}label{eq:Greeny}
x(t)&=&\int_{-\infty}^\infty dt'~F(t')\frac{e^{-\beta(t-t')}\sin[\omega'(t-t')]}{m\omega'}\Theta(t-t')\\
\nonumber
&=&\int_{-\infty}^\infty dt'~F(t')G(t-t'),\\
\nonumber
G(\Delta t)&=&\frac{e^{-\beta\Delta t}\sin[\omega' \Delta t]}{m\omega'}\Theta(\Delta t)
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
The quantity
\( e^{-\beta(t-t')}\sin[\omega'(t-t')]/m\omega'\Theta(t-t') \) is called a
Green's function, \( G(t-t') \). It describes the response at \( t \) due to a
force applied at a time \( t' \), and is a function of \( t-t' \). The step
function ensures that the response does not occur before the force is
applied. One should remember that the form for \( G \) would change if the
oscillator were either critically- or over-damped.

<p>
When performing the integral in Eq. \eqref{eq:Greeny} one can use
angle addition formulas to factor out the part with the \( t' \)
dependence in the integrand,

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tag{25}
x(t)&=&\frac{1}{m\omega'}e^{-\beta t}\left[I_c(t)\sin(\omega't)-I_s(t)\cos(\omega't)\right],\\
\nonumber
I_c(t)&\equiv&\int_{-\infty}^t dt'~F(t')e^{\beta t'}\cos(\omega't'),\\
\nonumber
I_s(t)&\equiv&\int_{-\infty}^t dt'~F(t')e^{\beta t'}\sin(\omega't').
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
If the time \( t \) is beyond any time at which the force acts,
\( F(t'>t)=0 \), the coefficients \( I_c \) and \( I_s \) become independent of
\( t \).

<p>
Consider an undamped oscillator (\( \beta\rightarrow 0 \)), with
characteristic frequency \( \omega_0 \) and mass \( m \), that is at rest
until it feels a force described by a Gaussian form,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
F(t)&=&F_0 \exp\left\{\frac{-t^2}{2\tau^2}\right\}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
For large times (\( t>>\tau \)), where the force has died off, find
\( x(t) \).\\ Solve for the coefficients \( I_c \) and \( I_s \) in
Eq. <a href="#mjx-eqn-25">(25)</a>. Because the Gaussian is an even function,
\( I_s=0 \), and one need only solve for \( I_c \),

<p>&nbsp;<br>
$$
\begin{eqnarray*}
I_c&=&F_0\int_{-\infty}^\infty dt'~e^{-t^{\prime 2}/(2\tau^2)}\cos(\omega_0 t')\\
&=&\Re F_0 \int_{-\infty}^\infty dt'~e^{-t^{\prime 2}/(2\tau^2)}e^{i\omega_0 t'}\\
&=&\Re F_0 \int_{-\infty}^\infty dt'~e^{-(t'-i\omega_0\tau^2)^2/(2\tau^2)}e^{-\omega_0^2\tau^2/2}\\
&=&F_0\tau \sqrt{2\pi} e^{-\omega_0^2\tau^2/2}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The third step involved completing the square, and the final step used the fact that the integral

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\int_{-\infty}^\infty dx~e^{-x^2/2}&=&\sqrt{2\pi}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
To see that this integral is true, consider the square of the integral, which you can change to polar coordinates,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
I&=&\int_{-\infty}^\infty dx~e^{-x^2/2}\\
I^2&=&\int_{-\infty}^\infty dxdy~e^{-(x^2+y^2)/2}\\
&=&2\pi\int_0^\infty rdr~e^{-r^2/2}\\
&=&2\pi.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Finally, the expression for \( x \) from Eq. <a href="#mjx-eqn-25">(25)</a> is

<p>&nbsp;<br>
$$
\begin{eqnarray*}
x(t>>\tau)&=&\frac{F_0\tau}{m\omega_0} \sqrt{2\pi} e^{-\omega_0^2\tau^2/2}\sin(\omega_0t).
\end{eqnarray*}
$$
<p>&nbsp;<br>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

    // Display navigation controls in the bottom right corner
    controls: true,

    // Display progress bar (below the horiz. slider)
    progress: true,

    // Display the page number of the current slide
    slideNumber: true,

    // Push each slide change to the browser history
    history: false,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    //center: true,
    center: false,

    // Enables touch navigation on devices with touch input
    touch: true,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Turns fragments on and off globally
    fragments: true,

    // Flags if the presentation is running in an embedded mode,
    // i.e. contained within a limited portion of the screen
    embedded: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Stop auto-sliding after user input
    autoSlideStoppable: true,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Hides the address bar on mobile devices
    hideAddressBar: true,

    // Opens links in an iframe preview overlay
    previewLinks: false,

    // Transition style
    transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

    // Transition speed
    transitionSpeed: 'default', // default/fast/slow

    // Transition style for full page slide backgrounds
    backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

    // Number of slides away from the current that are visible
    viewDistance: 3,

    // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

    // Parallax background size
    //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

    theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interpret Markdown in <section> elements
        { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntax highlight for <code> elements
        { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom in and out with Alt+click
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speaker notes
        { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remote control your reveal.js presentation using a touch device
        //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

        // MathJax
        //{ src: 'reveal.js/plugin/math/math.js', async: true }
    ]
});

Reveal.initialize({

    // The "normal" size of the presentation, aspect ratio will be preserved
    // when the presentation is scaled to fit different resolutions. Can be
    // specified using percentage units.
    width: 1170,  // original: 960,
    height: 700,

    // Factor of the display size that should remain empty around the content
    margin: 0.1,

    // Bounds for smallest/largest possible scale to apply to content
    minScale: 0.2,
    maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
     end footer logo -->



</body>
</html>

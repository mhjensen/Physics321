<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week11-reveal.html week11-reveal reveal --html_slide_theme=beige
-->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="PHY321: Two-body problems and Gravitational Forces">
<title>PHY321: Two-body problems and Gravitational Forces</title>

<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.reveal .alert-text-small   { font-size: 80%;  }
.reveal .alert-text-large   { font-size: 130%; }
.reveal .alert-text-normal  { font-size: 90%;  }
.reveal .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
  -webkit-border-radius: 14px; -moz-border-radius: 14px;
  border-radius:14px;
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.reveal .alert-block {padding-top:14px; padding-bottom:14px}
.reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
/*.reveal .alert li {margin-top: 1em}*/
.reveal .alert-block p+p {margin-top:5px}
/*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
.reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
.reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
.reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */
/* Override reveal.js table border */
.reveal table td {
  border: 0;
}

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
    -webkit-border-radius:14px; -moz-border-radius:14px;
  border-radius:14px
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.slide .alert-block {padding-top:14px; padding-bottom:14px}
.slide .alert-block > p, .alert-block > ul {margin-bottom:0}
/*.slide .alert li {margin-top: 1em}*/
.deck .alert-block p+p {margin-top:5px}
/*.slide .alert-notice { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_notice.png); }
.slide .alert-summary  { background-image:url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_summary.png); }
.slide .alert-warning { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_warning.png); }
.slide .alert-question {background-image:url(https://hplgit.github.io/doconce/
bundled/html_images/small_gray_question.png); } */
.dotable table, .dotable th, .dotable tr, .dotable tr td {
  border: 2px solid black;
  border-collapse: collapse;
  padding: 2px;
}
</style>


<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>


<body>
<div class="reveal">
<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<section>
<!-- ------------------- main content ---------------------- -->
<center>
<h1 style="text-align: center;">PHY321: Two-body problems and Gravitational Forces</h1>
</center>  <!-- document title -->

<!-- author(s): <a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a> -->
<center>
<b><a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a></b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics and Astronomy and Facility for Rare Ion Beams (FRIB), Michigan State University, USA</b>
</center>
<center>
[2] <b>Department of Physics, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>Mar 21, 2022</h4>
</center> <!-- date -->
<br>


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2022, "Morten Hjorth-Jensen":"http://mhjgit.github.io/info/doc/web/". Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>

<section>
<h2 id="aims-and-overarching-motivation">Aims and Overarching Motivation </h2>
<h3 id="monday-march-21">Monday March 21 </h3>

<p>Definition of the two-body problem, rewriting the equations in relative and center-of-mass coordinates</p>

<p><b>Reading suggestion</b>: Taylor sections 8.2-8.3</p>
<h3 id="wednesday-march-23">Wednesday March 23 </h3>

<p>Preparing the ground for the  gravitational force and its solution in two dimensions. 
Harmonic Oscillator example in two dimensions (if we get time).
</p>

<p><b>Reading suggestion</b>: Taylor chapter 8.4-8.5</p>
<h3 id="friday-march-25">Friday  March 25 </h3>

<p>Discussion and work on homework 7</p>
</section>

<section>
<h2 id="videos-of-possible-interest">Videos of possible interest </h2>

<ul>
<p><li> <a href="https://youtu.be/7nYIfV0z1VM" target="_blank">Video on solving differential equations numerically</a></li>
<p><li> <a href="https://youtu.be/neXZ4fb-4Rs" target="_blank">Video on Fourier aanalysis</a></li>
<p><li> <a href="https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/Spring2022/NotesFourierAnalysisMarch21.pdf" target="_blank">Handwritten notes for Fourier analysis</a></li>
</ul>
</section>

<section>
<h1 id="two-body-problems">Two-body Problems </h1>

<p>Two-body problems play a central role in physics. Some of these problems can, with appropriate transformations, be solved analytically. The gravitional force problem (as well as the Coulomb potential problem for two particles) is an example of this.</p>

<p>There are several small steps which we need to do in order to reach this solution. These are</p>
<ol>
<p><li> Rewriting the equations in terms of the degrees of freedom of the relative motion and the center of mass motion</li>
<p><li> Making a transformation either to polar (two dimensions) or to spherical coordinates (three dimensions)</li>
<p><li> This gives us uncoupled differential equations for each coordinate that we can solve analytically</li>
</ol>
<p>
<p>The advantage in doing so is that we can extract a lot of interesting insights about the motion and the physics of these important physics problems. These insights can be transferred to other physics problems where the potentials are given by expressions proportional with the inverse relative distance.</p>
</section>

<section>
<h2 id="the-gravitational-force">The gravitational force </h2>

<p>The gravitational potential energy and forces involving two masses \( a \) and \( b \) are</p>
<p>&nbsp;<br>
$$
\begin{eqnarray}
V_{ab}&=&-\frac{Gm_am_b}{|\boldsymbol{r}_a-\boldsymbol{r}_b|},\\
\nonumber
F_{ba}&=&-\frac{Gm_am_b}{|\boldsymbol{r}_a-\boldsymbol{r}_b|^2}\hat{r}_{ab},\\
\nonumber
\hat{r}_{ab}&=&\frac{\boldsymbol{r}_b-\boldsymbol{r}_a}{|\boldsymbol{r}_a-\boldsymbol{r}_b|}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>Here \( G=6.67\times 10^{-11} \) Nm$^2$/kg$^2$, and \( F_{ba} \) is the force
on \( b \) due to \( a \). By inspection, one can see that the force on \( b \)
due to \( a \) and the force on \( a \) due to \( b \) are equal and opposite. The
net potential energy for a large number of masses would be
</p>

<p>&nbsp;<br>
$$
\begin{equation}
V=\sum_{a < b}U_{ab}=\frac{1}{2}\sum_{a\ne b}V_{ab}.
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="relative-and-center-of-mass-motion">Relative and Center of Mass Motion </h2>

<p>Thus far, we have considered the trajectory as if the force is
centered around a fixed point. For two bodies interacting only with
one another, both masses circulate around the center of mass. One
might think that solutions would become more complex when both
particles move, but we will see here that the problem can be reduced
to one with a single body moving according to a fixed force by
expressing the trajectories for \( \boldsymbol{r}_1 \) and \( \boldsymbol{r}_2 \) into the
center-of-mass coordinate \( \boldsymbol{R}_{\rm cm} \) and the relative
coordinate \( \boldsymbol{r} \),
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\boldsymbol{R}_{\rm cm}&\equiv&\frac{m_1\boldsymbol{r}_1+m_2\boldsymbol{r}_2}{m_1+m_2},\\
\nonumber
\boldsymbol{r}&\equiv&\boldsymbol{r}_1-\boldsymbol{r_2}.
\end{eqnarray}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="relative-and-center-of-mass-motion-assumptions">Relative and Center of Mass Motion, assumptions </h2>

<p>Here, we assume the two particles interact only with one another, so
\( \boldsymbol{F}_{12}=-\boldsymbol{F}_{21} \) (where \( \boldsymbol{F}_{ij} \) is the force on \( i \)
due to \( j \). The equations of motion then become
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\ddot{\boldsymbol{R}}_{\rm cm}&=&\frac{1}{m_1+m_2}\left\{m_1\ddot{\boldsymbol{r}}_1+m_2\ddot{\boldsymbol{r}}_2\right\}\\
\nonumber
&=&\frac{1}{m_1+m_2}\left\{\boldsymbol{F}_{12}+\boldsymbol{F}_{21}\right\}=0.\\
\ddot{\boldsymbol{r}}&=&\ddot{\boldsymbol{r}}_1-\ddot{\boldsymbol{r}}_2=\left(\frac{\boldsymbol{F}_{12}}{m_1}-\frac{\boldsymbol{F}_{21}}{m_2}\right)\\
\nonumber
&=&\left(\frac{1}{m_1}+\frac{1}{m_2}\right)\boldsymbol{F}_{12}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>The first expression simply states that the center of mass coordinate
\( \boldsymbol{R}_{\rm cm} \) moves at a fixed velocity. The second expression
can be rewritten in terms of the reduced mass \( \mu \).
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\mu \ddot{\boldsymbol{r}}&=&\boldsymbol{F}_{12},\\
\frac{1}{\mu}&=&\frac{1}{m_1}+\frac{1}{m_2},~~~~\mu=\frac{m_1m_2}{m_1+m_2}.
\end{eqnarray}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="trajectory-as-a-one-body-problem">Trajectory as a one-body problem </h2>

<p>Thus, one can treat the trajectory as a one-body problem where the
reduced mass is \( \mu \), and a second trivial problem for the center of
mass. The reduced mass is especially convenient when one is
considering gravitational problems because then
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\mu \ddot{r}&=&-\frac{Gm_1m_2}{r^2}\hat{r}\\
\nonumber
&=&-\frac{GM\mu}{r^2}\hat{r},~~~M\equiv m_1+m_2.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>For the gravitational problem, the reduced mass then falls out and the
trajectory depends only on the total mass \( M \).
</p>

<p>The kinetic energy and momenta also have analogues in center-of-mass
coordinates. The total and relative momenta are
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\boldsymbol{P}&\equiv&\boldsymbol{p}_1+\boldsymbol{p}_2=M\dot{\boldsymbol{R}}_{\rm cm},\\
\nonumber
\boldsymbol{q}&\equiv&\mu\dot{\boldsymbol{r}}.
\end{eqnarray}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="kinetic-energy">Kinetic energy </h2>

<p>With these definitions, a little algebra shows that the kinetic energy becomes</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
K&=&\frac{1}{2}m_1|\boldsymbol{v}_1|^2+\frac{1}{2}m_2|\boldsymbol{v}_2|^2\\
\nonumber
&=&\frac{1}{2}M|\dot{\boldsymbol{R}}_{\rm cm}|^2
+\frac{1}{2}\mu|\dot{\boldsymbol{r}}|^2\\
\nonumber
&=&\frac{P^2}{2M}+\frac{q^2}{2\mu}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>The standard strategy is to transform into the center of mass frame,
then treat the problem as one of a single particle of mass \( \mu \)
undergoing a force \( \boldsymbol{F}_{12} \). Scattering angles can also be
expressed in this frame, then transformed into the lab frame. In
practice, one sees examples in the literature where \( d\sigma/d\Omega \)
expressed in both the &quot;center-of-mass&quot; and in the &quot;laboratory&quot;
frame.
</p>
</section>

<section>
<h2 id="deriving-elliptical-orbits">Deriving Elliptical Orbits </h2>

<p>Kepler's laws state that a gravitational orbit should be an ellipse
with the source of the gravitational field at one focus. Deriving this
is surprisingly messy. To do this, we first use angular momentum
conservation to transform the equations of motion so that it is in
terms of \( r \) and \( \theta \) instead of \( r \) and \( t \). The overall strategy
is to
</p>

<ol>
<p><li> Find equations of motion for \( r \) and \( t \) with no angle (\( \theta \)) mentioned, i.e. \( d^2r/dt^2=\cdots \). Angular momentum conservation will be used, and the equation will involve the angular momentum \( L \).</li>
<p><li> Use angular momentum conservation to find an expression for \( \dot{\theta} \) in terms of \( r \).</li>
<p><li> Use the chain rule to convert the equations of motions for \( r \), an expression involving \( r,\dot{r} \) and \( \ddot{r} \), to one involving \( r,dr/d\theta \) and \( d^2r/d\theta^2 \). This is quitecomplicated because the expressions will also involve a substitution \( u=1/r \) so that one finds an expression in terms of \( u \) and \( \theta \).</li>
<p><li> Once \( u(\theta) \) is found, you need to show that this can be converted to the familiar form for an ellipse.</li>
</ol>
</section>

<section>
<h2 id="euqations-of-motion">Euqations of motion </h2>
<p>The equations of motion give</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tag{2}
\frac{d}{dt}r^2&=&\frac{d}{dt}(x^2+y^2)=2x\dot{x}+2y\dot{y}=2r\dot{r},\\
\nonumber
\dot{r}&=&\frac{x}{r}\dot{x}+\frac{y}{r}\dot{y},\\
\nonumber
\ddot{r}&=&\frac{x}{r}\ddot{x}+\frac{y}{r}\ddot{y}
+\frac{\dot{x}^2+\dot{y}^2}{r}
-\frac{\dot{r}^2}{r}.
\end{eqnarray}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="reordering-the-equations">Reordering the equations </h2>
<p>Recognizing that the numerator of the third term is the velocity squared, and that it can be written in polar coordinates, </p>

<p>&nbsp;<br>
$$
\begin{equation}
v^2=\dot{x}^2+\dot{y}^2=\dot{r}^2+r^2\dot{\theta}^2,
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>

<p>one can write \( \ddot{r} \) as</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tag{4}
\ddot{r}&=&\frac{F_x\cos\theta+F_y\sin\theta}{m}+\frac{\dot{r}^2+r^2\dot{\theta}^2}{r}-\frac{\dot{r}^2}{r}\\
\nonumber
&=&\frac{F}{m}+\frac{r^2\dot{\theta}^2}{r}\\
\nonumber
m\ddot{r}&=&F+\frac{L^2}{mr^3}.
\end{eqnarray}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="force-depends-on-r-only">Force depends on \( r \) only </h2>

<p>This derivation used the fact that the force was radial,
\( F=F_r=F_x\cos\theta+F_y\sin\theta \), and that angular momentum is
\( L=mrv_{\theta}=mr^2\dot{\theta} \). The term \( L^2/mr^3=mv^2/r \) behaves
like an additional force. Sometimes this is referred to as a
centrifugal force, but it is not a force. Instead, it is the
consequence of considering the motion in a rotating (and therefore
accelerating) frame.
</p>

<p>Now, we switch to the particular case of an attractive inverse square
force, \( F=-\alpha/r^2 \), and show that the trajectory, \( r(\theta) \), is
an ellipse. To do this we transform derivatives w.r.t. time to
derivatives w.r.t. \( \theta \) using the chain rule combined with angular
momentum conservation, \( \dot{\theta}=L/mr^2 \).
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tag{5}
\dot{r}&=&\frac{dr}{d\theta}\dot{\theta}=\frac{dr}{d\theta}\frac{L}{mr^2},\\
\nonumber
\ddot{r}&=&\frac{d^2r}{d\theta^2}\dot{\theta}^2
+\frac{dr}{d\theta}\left(\frac{d}{dr}\frac{L}{mr^2}\right)\dot{r}\\
\nonumber
&=&\frac{d^2r}{d\theta^2}\left(\frac{L}{mr^2}\right)^2
-2\frac{dr}{d\theta}\frac{L}{mr^3}\dot{r}\\
\nonumber
&=&\frac{d^2r}{d\theta^2}\left(\frac{L}{mr^2}\right)^2
-\frac{2}{r}\left(\frac{dr}{d\theta}\right)^2\left(\frac{L}{mr^2}\right)^2
\end{eqnarray}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="further-manipulations">Further manipulations </h2>

<p>Equating the two expressions for \( \ddot{r} \) in Eq.s <a href="#mjx-eqn-4">(4)</a> and <a href="#mjx-eqn-5">(5)</a> eliminates all the derivatives w.r.t. time, and provides a differential equation with only derivatives w.r.t. \( \theta \),</p>

<p>&nbsp;<br>
$$
\begin{equation}
\tag{6}
\frac{d^2r}{d\theta^2}\left(\frac{L}{mr^2}\right)^2
-\frac{2}{r}\left(\frac{dr}{d\theta}\right)^2\left(\frac{L}{mr^2}\right)^2
=\frac{F}{m}+\frac{L^2}{m^2r^3},
\end{equation}
$$
<p>&nbsp;<br>

<p>that when solved yields the trajectory, i.e. \( r(\theta) \). Up to this
point the expressions work for any radial force, not just forces that
fall as \( 1/r^2 \).
</p>
</section>

<section>
<h2 id="final-manipulations-part-1">Final manipulations, part 1  </h2>

<p>The trick to simplifying this differential equation for the inverse
square problems is to make a substitution, \( u\equiv 1/r \), and rewrite
the differential equation for \( u(\theta) \).
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
r&=&1/u,\\
\nonumber
\frac{dr}{d\theta}&=&-\frac{1}{u^2}\frac{du}{d\theta},\\
\nonumber
\frac{d^2r}{d\theta^2}&=&\frac{2}{u^3}\left(\frac{du}{d\theta}\right)^2-\frac{1}{u^2}\frac{d^2u}{d\theta^2}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>Plugging these expressions into Eq. <a href="#mjx-eqn-6">(6)</a> gives an
expression in terms of \( u \), \( du/d\theta \), and \( d^2u/d\theta^2 \). After
some tedious algebra,
</p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{d^2u}{d\theta^2}=-u-\frac{F m}{L^2u^2}.
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="final-manipulations-part-2">Final manipulations, part 2  </h2>

<p>For the attractive inverse square law force, \( F=-\alpha u^2 \),</p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{d^2u}{d\theta^2}=-u+\frac{m\alpha}{L^2}.
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>

<p>The solution has two arbitrary constants, \( A \) and \( \theta_0 \),</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tag{9}
u&=&\frac{m\alpha}{L^2}+A\cos(\theta-\theta_0),\\
\nonumber
r&=&\frac{1}{(m\alpha/L^2)+A\cos(\theta-\theta_0)}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>The radius will be at a minimum when \( \theta=\theta_0 \) and at a
maximum when \( \theta=\theta_0+\pi \). The constant \( A \) is related to the
eccentricity of the orbit. When \( A=0 \) the radius is a constant
\( r=L^2/(m\alpha) \), and the motion is circular. If one solved the
expression \( mv^2/r=-\alpha/r^2 \) for a circular orbit, using the
substitution \( v=L/(mr) \), one would reproduce the expression
\( r=L^2/(m\alpha) \).
</p>
</section>

<section>
<h2 id="final-manipulations-part-3">Final manipulations, part 3  </h2>

<p>The form describing the elliptical trajectory in
Eq. <a href="#mjx-eqn-9">(9)</a> can be identified as an ellipse with one
focus being the center of the ellipse by considering the definition of
an ellipse as being the points such that the sum of the two distances
between the two foci are a constant. Making that distance \( 2D \), the
distance between the two foci as \( 2a \), and putting one focus at the
origin,
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
2D&=&r+\sqrt{(r\cos\theta-2a)^2+r^2\sin^2\theta},\\
\nonumber
4D^2+r^2-4Dr&=&r^2+4a^2-4ar\cos\theta,\\
\nonumber
r&=&\frac{D^2-a^2}{D+a\cos\theta}=\frac{1}{D/(D^2-a^2)-a\cos\theta/(D^2-a^2)}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>By inspection, this is the same form as Eq. <a href="#mjx-eqn-9">(9)</a> with \( D/(D^2-a^2)=m\alpha/L^2 \) and \( a/(D^2-a^2)=A \).</p>
</section>

<section>
<h2 id="ellipse-reminder">Ellipse reminder  </h2>

<p>Let us remind ourselves about what an ellipse is before we proceed.</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib</span> <span style="color: #8B008B; font-weight: bold">import</span> pyplot <span style="color: #8B008B; font-weight: bold">as</span> plt
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> pi

u=<span style="color: #B452CD">1.</span>     <span style="color: #228B22">#x-position of the center</span>
v=<span style="color: #B452CD">0.5</span>    <span style="color: #228B22">#y-position of the center</span>
a=<span style="color: #B452CD">2.</span>     <span style="color: #228B22">#radius on the x-axis</span>
b=<span style="color: #B452CD">1.5</span>    <span style="color: #228B22">#radius on the y-axis</span>

t = np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>*pi, <span style="color: #B452CD">100</span>)
plt.plot( u+a*np.cos(t) , v+b*np.sin(t) )
plt.grid(color=<span style="color: #CD5555">&#39;lightgray&#39;</span>,linestyle=<span style="color: #CD5555">&#39;--&#39;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="effective-or-centrifugal-potential">Effective or Centrifugal Potential </h2>

<p>The total energy of a particle is</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
E&=&V(r)+\frac{1}{2}mv_\theta^2+\frac{1}{2}m\dot{r}^2\\
\nonumber
&=&V(r)+\frac{1}{2}mr^2\dot{\theta}^2+\frac{1}{2}m\dot{r}^2\\
\nonumber
&=&V(r)+\frac{L^2}{2mr^2}+\frac{1}{2}m\dot{r}^2.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>The second term then contributes to the energy like an additional
repulsive potential. The term is sometimes referred to as the
"centrifugal" potential, even though it is actually the kinetic energy
of the angular motion. Combined with \( V(r) \), it is sometimes referred
to as the "effective" potential,
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
V_{\rm eff}(r)&=&V(r)+\frac{L^2}{2mr^2}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>Note that if one treats the effective potential like a real potential, one would expect to be able to generate an effective force,</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
F_{\rm eff}&=&-\frac{d}{dr}V(r) -\frac{d}{dr}\frac{L^2}{2mr^2}\\
\nonumber
&=&F(r)+\frac{L^2}{mr^3}=F(r)+m\frac{v_\perp^2}{r},
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>which is indeed matches the form for \( m\ddot{r} \) in Eq. <a href="#mjx-eqn-4">(4)</a>, which included the <b>centrifugal</b> force.</p>
</section>

<section>
<h2 id="code-example">Code example </h2>

<p>The following code plots this effective potential for a simple choice of parameters, with a standard gravitational potential \( -\alpha/r \). Here we have chosen \( L=m=\alpha=1 \). </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

Deltax = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays</span>
xinitial = <span style="color: #B452CD">0.3</span>
xfinal = <span style="color: #B452CD">5.0</span>
alpha = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># spring constant</span>
m = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># mass, you can change these</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
n = ceil((xfinal-xinitial)/Deltax)
x = np.zeros(n)
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
    x[i] = xinitial+i*Deltax
V = np.zeros(n)
V = -alpha/x+<span style="color: #B452CD">0.5</span>*AngMom*AngMom/(m*x*x)
<span style="color: #228B22"># Plot potential</span>
fig, ax = plt.subplots()
ax.set_xlabel(<span style="color: #CD5555">&#39;r[m]&#39;</span>)
ax.set_ylabel(<span style="color: #CD5555">&#39;V[J]&#39;</span>)
ax.plot(x, V)
fig.tight_layout()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="gravitational-force-example">Gravitational force example </h2>

<p>Using the above parameters, we can now study the evolution of the system using for example the velocity Verlet method.
This is done in the code here for an initial radius equal to the minimum of the potential well.  We seen then that the radius is always the same and corresponds to a circle (the radius is always constant).
</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)


<span style="color: #228B22"># Simple Gravitational Force   -alpha/r</span>
    
DeltaT = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">100.0</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v and r</span>
t = np.zeros(n)
v = np.zeros(n)
r = np.zeros(n)
<span style="color: #228B22"># Constants of the model, setting all variables to one for simplicity</span>
alpha = <span style="color: #B452CD">1.0</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
m = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22"># scale mass to one</span>
c1 = AngMom*AngMom/(m*m)
c2 = AngMom*AngMom/m
rmin = (AngMom*AngMom/m/alpha)
<span style="color: #228B22"># Initial conditions</span>
r0 = rmin
v0 = <span style="color: #B452CD">0.0</span>
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
<span style="color: #228B22"># Start integrating using the Velocity-Verlet  method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up acceleration</span>
    a = -alpha/(r[i]**<span style="color: #B452CD">2</span>)+c1/(r[i]**<span style="color: #B452CD">3</span>)
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*(DeltaT**<span style="color: #B452CD">2</span>)*a
    anew = -alpha/(r[i+<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)+c1/(r[i+<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
    <span style="color: #228B22"># Plot position as function of time</span>
fig, ax = plt.subplots(<span style="color: #B452CD">2</span>,<span style="color: #B452CD">1</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;radius&#39;</span>)
ax[<span style="color: #B452CD">0</span>].plot(t,r)
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_ylabel(<span style="color: #CD5555">&#39;Velocity&#39;</span>)
ax[<span style="color: #B452CD">1</span>].plot(t,v)
save_fig(<span style="color: #CD5555">&quot;RadialGVV&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Changing the value of the initial position to a value where the energy is positive, leads to an increasing radius with time, a so-called unbound orbit. Choosing on the other hand an initial radius that corresponds to a negative energy and different from the minimum value leads to a radius that oscillates back and forth between two values. </p>
</section>

<section>
<h2 id="harmonic-oscillator-in-two-dimensions">Harmonic Oscillator in two dimensions </h2>

<p>Consider a particle of mass \( m \) in a 2-dimensional harmonic oscillator with potential</p>

<p>&nbsp;<br>
$$
V=\frac{1}{2}kr^2=\frac{1}{2}k(x^2+y^2).
$$
<p>&nbsp;<br>

<p>If the orbit has angular momentum \( L \), we can find the radius and angular velocity of the circular orbit as well as the b) the angular frequency of small radial perturbations.</p>

<p>We consider the effective potential. The radius of a circular orbit is at the minimum of the potential (where the effective force is zero).
The potential is plotted here with the parameters \( k=m=0.1 \) and \( L=1.0 \).
</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

Deltax = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays</span>
xinitial = <span style="color: #B452CD">0.5</span>
xfinal = <span style="color: #B452CD">3.0</span>
k = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># spring constant</span>
m = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># mass, you can change these</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
n = ceil((xfinal-xinitial)/Deltax)
x = np.zeros(n)
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
    x[i] = xinitial+i*Deltax
V = np.zeros(n)
V = <span style="color: #B452CD">0.5</span>*k*x*x+<span style="color: #B452CD">0.5</span>*AngMom*AngMom/(m*x*x)
<span style="color: #228B22"># Plot potential</span>
fig, ax = plt.subplots()
ax.set_xlabel(<span style="color: #CD5555">&#39;r[m]&#39;</span>)
ax.set_ylabel(<span style="color: #CD5555">&#39;V[J]&#39;</span>)
ax.plot(x, V)
fig.tight_layout()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>&nbsp;<br>
$$
\begin{eqnarray*}
V_{\rm eff}&=&\frac{1}{2}kr^2+\frac{L^2}{2mr^2}
\end{eqnarray*}
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="harmonic-oscillator-in-two-dimensions-and-effective-potential">Harmonic oscillator in two dimensions and effective potential </h2>
<p>The effective potential looks like that of a harmonic oscillator for
large \( r \), but for small \( r \), the centrifugal potential repels the
particle from the origin. The combination of the two potentials has a
minimum for at some radius \( r_{\rm min} \). 
</p>

<p>&nbsp;<br>
$$
\begin{eqnarray*}
0&=&kr_{\rm min}-\frac{L^2}{mr_{\rm min}^3},\\
r_{\rm min}&=&\left(\frac{L^2}{mk}\right)^{1/4},\\
\dot{\theta}&=&\frac{L}{mr_{\rm min}^2}=\sqrt{k/m}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>For particles at \( r_{\rm min} \) with \( \dot{r}=0 \), the particle does not
accelerate and \( r \) stays constant, i.e. a circular orbit. The radius
of the circular orbit can be adjusted by changing the angular momentum
\( L \).
</p>

<p>For the above parameters this minimum is at \( r_{\rm min}=1 \).</p>

<p> Now consider small vibrations about \( r_{\rm min} \). The effective spring constant is the curvature of the effective potential.</p>

<p>&nbsp;<br>
$$
\begin{eqnarray*}
k_{\rm eff}&=&\left.\frac{d^2}{dr^2}V_{\rm eff}(r)\right|_{r=r_{\rm min}}=k+\frac{3L^2}{mr_{\rm min}^4}\\
&=&4k,\\
\omega&=&\sqrt{k_{\rm eff}/m}=2\sqrt{k/m}=2\dot{\theta}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>Because the radius oscillates with twice the angular frequency,
the orbit has two places where \( r \) reaches a minimum in one
cycle. This differs from the inverse-square force where there is one
minimum in an orbit. One can show that the orbit for the harmonic
oscillator is also elliptical, but in this case the center of the
potential is at the center of the ellipse, not at one of the foci.
</p>

<p>The solution is also simple to write down exactly in Cartesian coordinates. The \( x \) and \( y \) equations of motion separate,</p>

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\ddot{x}&=&-kx,\\
\ddot{y}&=&-ky.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>The general solution can be expressed as</p>

<p>&nbsp;<br>
$$
\begin{eqnarray*}
x&=&A\cos\omega_0 t+B\sin\omega_0 t,\\
y&=&C\cos\omega_0 t+D\sin\omega_0 t.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>The code here finds the solution for \( x \) and \( y \) using the code we
developed in homework 5 and 6 and the midterm.  Note that this code is
tailored to run in Cartesian coordinates. There is thus no angular
momentum dependent term.
</p>

<p>Here we have chose initial conditions that
correspond to the minimum of the effective potential
\( r_{\mathrm{min}} \). We have chosen \( x_0=r_{\mathrm{min}} \) and
\( y_0=0 \). Similarly, we use the centripetal acceleration to determine
the initial velocity so that we have a circular motion (see back to the
last question of the midterm). This means that we set the centripetal
acceleration \( v^2/r \) equal to the force from the harmonic oscillator \( -k\boldsymbol{r} \). Taking the
magnitude of \( \boldsymbol{r} \) we have then
\( v^2/r=k/mr \), which gives \( v=\pm\omega_0r \). 
</p>

<p>Since the code here solves the equations of motion in cartesian
coordinates and the harmonic oscillator potential leads to forces in
the \( x \)- and \( y \)-directions that are decoupled, we have to select the initial velocities and positions so that we don't get that for example \( y(t)=0 \).
</p>

<p>We set \( x_0 \) to be different from zero and \( v_{y0} \) to be different from zero.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">DeltaT = <span style="color: #B452CD">0.001</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">10.0</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays</span>
t = np.zeros(n)
v = np.zeros((n,<span style="color: #B452CD">2</span>))
r = np.zeros((n,<span style="color: #B452CD">2</span>))
radius = np.zeros(n)
<span style="color: #228B22"># Constants of the model</span>
k = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># spring constant</span>
m = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># mass, you can change these</span>
omega02 = k/m  <span style="color: #228B22"># Frequency</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
<span style="color: #228B22"># Potential minimum</span>
rmin = (AngMom*AngMom/k/m)**<span style="color: #B452CD">0.25</span>
<span style="color: #228B22"># Initial conditions as compact 2-dimensional arrays, x0=rmin and y0 = 0</span>
x0 = rmin; y0= <span style="color: #B452CD">0.0</span>
r0 = np.array([x0,y0])
vy0 = sqrt(omega02)*rmin; vx0 = <span style="color: #B452CD">0.0</span>
v0 = np.array([vx0,vy0])
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
<span style="color: #228B22"># Start integrating using the Velocity-Verlet  method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up the acceleration</span>
    a =  -r[i]*omega02  
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*(DeltaT**<span style="color: #B452CD">2</span>)*a
    anew = -r[i+<span style="color: #B452CD">1</span>]*omega02  
    v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
<span style="color: #228B22"># Plot position as function of time</span>
radius = np.sqrt(r[:,<span style="color: #B452CD">0</span>]**<span style="color: #B452CD">2</span>+r[:,<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)
fig, ax = plt.subplots(<span style="color: #B452CD">3</span>,<span style="color: #B452CD">1</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;radius squared&#39;</span>)
ax[<span style="color: #B452CD">0</span>].plot(t,r[:,<span style="color: #B452CD">0</span>]**<span style="color: #B452CD">2</span>+r[:,<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_ylabel(<span style="color: #CD5555">&#39;x position&#39;</span>)
ax[<span style="color: #B452CD">1</span>].plot(t,r[:,<span style="color: #B452CD">0</span>])
ax[<span style="color: #B452CD">2</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">2</span>].set_ylabel(<span style="color: #CD5555">&#39;y position&#39;</span>)
ax[<span style="color: #B452CD">2</span>].plot(t,r[:,<span style="color: #B452CD">1</span>])

fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;2DimHOVV&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We see that the radius (to within a given error), we obtain a constant radius.</p>

<p>The following code shows first how we can solve this problem using the radial degrees of freedom only.
Here we need to add the explicit centrifugal barrier.  Note that the variable \( r \) depends only on time. There is no \( x \) and \( y \) directions
since we have transformed the equations to polar coordinates.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;">DeltaT = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">10.0</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v and r</span>
t = np.zeros(n)
v = np.zeros(n)
r = np.zeros(n)
E = np.zeros(n)
<span style="color: #228B22"># Constants of the model</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
m = <span style="color: #B452CD">1.0</span>
k = <span style="color: #B452CD">1.0</span>
omega02 = k/m
c1 = AngMom*AngMom/(m*m)
c2 = AngMom*AngMom/m
rmin = (AngMom*AngMom/k/m)**<span style="color: #B452CD">0.25</span>
<span style="color: #228B22"># Initial conditions</span>
r0 = rmin
v0 = <span style="color: #B452CD">0.0</span>
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
E[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.5</span>*m*v0*v0+<span style="color: #B452CD">0.5</span>*k*r0*r0+<span style="color: #B452CD">0.5</span>*c2/(r0*r0)
<span style="color: #228B22"># Start integrating using the Velocity-Verlet  method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up acceleration</span>
    a = -r[i]*omega02+c1/(r[i]**<span style="color: #B452CD">3</span>)    
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*(DeltaT**<span style="color: #B452CD">2</span>)*a
    anew = -r[i+<span style="color: #B452CD">1</span>]*omega02+c1/(r[i+<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
    E[i+<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0.5</span>*m*v[i+<span style="color: #B452CD">1</span>]*v[i+<span style="color: #B452CD">1</span>]+<span style="color: #B452CD">0.5</span>*k*r[i+<span style="color: #B452CD">1</span>]*r[i+<span style="color: #B452CD">1</span>]+<span style="color: #B452CD">0.5</span>*c2/(r[i+<span style="color: #B452CD">1</span>]*r[i+<span style="color: #B452CD">1</span>])
    <span style="color: #228B22"># Plot position as function of time</span>
fig, ax = plt.subplots(<span style="color: #B452CD">2</span>,<span style="color: #B452CD">1</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;radius&#39;</span>)
ax[<span style="color: #B452CD">0</span>].plot(t,r)
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_ylabel(<span style="color: #CD5555">&#39;Energy&#39;</span>)
ax[<span style="color: #B452CD">1</span>].plot(t,E)
save_fig(<span style="color: #CD5555">&quot;RadialHOVV&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>With some work using double angle formulas, one can calculate</p>

<p>&nbsp;<br>
$$
\begin{eqnarray*}
r^2&=&x^2+y^2\\
\nonumber
&=&(A^2+C^2)\cos^2(\omega_0t)+(B^2+D^2)\sin^2\omega_0t+(AB+CD)\cos(\omega_0t)\sin(\omega_0t)\\
\nonumber
&=&\alpha+\beta\cos 2\omega_0 t+\gamma\sin 2\omega_0 t,\\
\alpha&=&\frac{A^2+B^2+C^2+D^2}{2},~~\beta=\frac{A^2-B^2+C^2-D^2}{2},~~\gamma=AB+CD,\\
r^2&=&\alpha+(\beta^2+\gamma^2)^{1/2}\cos(2\omega_0 t-\delta),~~~\delta=\arctan(\gamma/\beta),
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>and see that radius oscillates with frequency \( 2\omega_0 \). The
factor of two comes because the oscillation \( x=A\cos\omega_0t \) has two
maxima for \( x^2 \), one at \( t=0 \) and one a half period later.
</p>
</section>

<section>
<h2 id="stability-of-orbits">Stability of Orbits </h2>

<p>The effective force can be extracted from the effective potential, \( V_{\rm eff} \). Beginning from the equations of motion, Eq. <a href="#mjx-eqn-2">(2)</a>, for \( r \),</p>

<p>&nbsp;<br>
$$
\begin{eqnarray}
m\ddot{r}&=&F+\frac{L^2}{mr^3}\\
\nonumber
&=&F_{\rm eff}\\
\nonumber
&=&-\partial_rV_{\rm eff},\\
\nonumber
F_{\rm eff}&=&-\partial_r\left[V(r)+(L^2/2mr^2)\right].
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>For a circular orbit, the radius must be fixed as a function of time,
so one must be at a maximum or a minimum of the effective
potential. However, if one is at a maximum of the effective potential
the radius will be unstable. For the attractive Coulomb force the
effective potential will be dominated by the \( -\alpha/r \) term for
large \( r \) because the centrifugal part falls off more quickly, \( \sim
1/r^2 \). At low \( r \) the centrifugal piece wins and the effective
potential is repulsive. Thus, the potential must have a minimum
somewhere with negative potential. The circular orbits are then stable
to perturbation.
</p>

<p>The effective potential is sketched for two cases, a \( 1/r \) attractive
potential and a \( 1/r^3 \) attractive potential. The \( 1/r \) case has a
stable minimum, whereas the circular orbit in the \( 1/r^3 \) case is
unstable.
</p>

<p>If one considers a potential that falls as \( 1/r^3 \), the situation is
reversed and the point where \( \partial_rV \) disappears will be a local
maximum rather than a local minimum. <b>Fig to come here with code</b>
</p>

<p>The repulsive centrifugal piece dominates at large \( r \) and the attractive
Coulomb piece wins out at small \( r \). The circular orbit is then at a
maximum of the effective potential and the orbits are unstable. It is
the clear that for potentials that fall as \( r^n \), that one must have
\( n>-2 \) for the orbits to be stable.
</p>

<p>Consider a potential \( V(r)=\beta r \). For a particle of mass \( m \) with
angular momentum \( L \), find the angular frequency of a circular
orbit. Then find the angular frequency for small radial perturbations.
</p>

<p>For the circular orbit you search for the position \( r_{\rm min} \) where the effective potential is minimized,</p>

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\partial_r\left\{\beta r+\frac{L^2}{2mr^2}\right\}&=&0,\\
\beta&=&\frac{L^2}{mr_{\rm min}^3},\\
r_{\rm min}&=&\left(\frac{L^2}{\beta m}\right)^{1/3},\\
\dot{\theta}&=&\frac{L}{mr_{\rm min}^2}=\frac{\beta^{2/3}}{(mL)^{1/3}}
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>Now, we can find the angular frequency of small perturbations about the circular orbit. To do this we find the effective spring constant for the effective potential,</p>

<p>&nbsp;<br>
$$
\begin{eqnarray*}
k_{\rm eff}&=&\partial_r^2 \left.V_{\rm eff}\right|_{r_{\rm min}}\\
&=&\frac{3L^2}{mr_{\rm min}^4},\\
\omega&=&\sqrt{\frac{k_{\rm eff}}{m}}\\
&=&\frac{\beta^{2/3}}{(mL)^{1/3}}\sqrt{3}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>If the two frequencies, \( \dot{\theta} \) and \( \omega \), differ by an
integer factor, the orbit's trajectory will repeat itself each time
around. This is the case for the inverse-square force,
\( \omega=\dot{\theta} \), and for the harmonic oscillator,
\( \omega=2\dot{\theta} \). In this case, \( \omega=\sqrt{3}\dot{\theta} \),
and the angles at which the maxima and minima occur change with each
orbit.
</p>
<h3 id="code-example-with-gravitional-force">Code example with gravitional force </h3>

<p>The code example here is meant to illustrate how we can make a plot of the final orbit. We solve the equations in polar coordinates (the example here uses the minimum of the potential as initial value) and then we transform back to cartesian coordinates and plot \( x \) versus \( y \). We see that we get a perfect circle when we place ourselves at the minimum of the potential energy, as expected.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Simple Gravitational Force   -alpha/r</span>
    
DeltaT = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">8.0</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v and r</span>
t = np.zeros(n)
v = np.zeros(n)
r = np.zeros(n)
phi = np.zeros(n)
x = np.zeros(n)
y = np.zeros(n)
<span style="color: #228B22"># Constants of the model, setting all variables to one for simplicity</span>
alpha = <span style="color: #B452CD">1.0</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
m = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22"># scale mass to one</span>
c1 = AngMom*AngMom/(m*m)
c2 = AngMom*AngMom/m
rmin = (AngMom*AngMom/m/alpha)
<span style="color: #228B22"># Initial conditions, place yourself at the potential min</span>
r0 = rmin
v0 = <span style="color: #B452CD">0.0</span>  <span style="color: #228B22"># starts at rest</span>
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
phi[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.0</span>
<span style="color: #228B22"># Start integrating using the Velocity-Verlet  method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up acceleration</span>
    a = -alpha/(r[i]**<span style="color: #B452CD">2</span>)+c1/(r[i]**<span style="color: #B452CD">3</span>)
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*(DeltaT**<span style="color: #B452CD">2</span>)*a
    anew = -alpha/(r[i+<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)+c1/(r[i+<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
    phi[i+<span style="color: #B452CD">1</span>] = t[i+<span style="color: #B452CD">1</span>]*c2/(r0**<span style="color: #B452CD">2</span>)
<span style="color: #228B22"># Find cartesian coordinates for easy plot    </span>
x = r*np.cos(phi)
y = r*np.sin(phi)
fig, ax = plt.subplots(<span style="color: #B452CD">3</span>,<span style="color: #B452CD">1</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;radius&#39;</span>)
ax[<span style="color: #B452CD">0</span>].plot(t,r)
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_ylabel(<span style="color: #CD5555">&#39;Angle $\cos{\phi}$&#39;</span>)
ax[<span style="color: #B452CD">1</span>].plot(t,np.cos(phi))
ax[<span style="color: #B452CD">2</span>].set_ylabel(<span style="color: #CD5555">&#39;y&#39;</span>)
ax[<span style="color: #B452CD">2</span>].set_xlabel(<span style="color: #CD5555">&#39;x&#39;</span>)
ax[<span style="color: #B452CD">2</span>].plot(x,y)

save_fig(<span style="color: #CD5555">&quot;Phasespace&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Try to change the initial value for \( r \) and see what kind of orbits you get.
In order to test different energies, it can be useful to look at the plot of the effective potential discussed above.
</p>

<p>However, for orbits different from a circle the above code would need modifications in order to allow us to display say an ellipse. For the latter, it is much easier to run our code in cartesian coordinates, as done here. In this code we test also energy conservation and see that it is conserved to numerical precision. The code here is a simple extension of the code we developed for homework 4.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

DeltaT = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">10.0</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays</span>
t = np.zeros(n)
v = np.zeros((n,<span style="color: #B452CD">2</span>))
r = np.zeros((n,<span style="color: #B452CD">2</span>))
E = np.zeros(n)
<span style="color: #228B22"># Constants of the model</span>
m = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># mass, you can change these</span>
alpha = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Initial conditions as compact 2-dimensional arrays</span>
x0 = <span style="color: #B452CD">0.5</span>; y0= <span style="color: #B452CD">0.</span>
r0 = np.array([x0,y0]) 
v0 = np.array([<span style="color: #B452CD">0.0</span>,<span style="color: #B452CD">1.0</span>])
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
rabs = sqrt(<span style="color: #658b00">sum</span>(r[<span style="color: #B452CD">0</span>]*r[<span style="color: #B452CD">0</span>]))
E[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.5</span>*m*(v[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>]**<span style="color: #B452CD">2</span>+v[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)-alpha/rabs
<span style="color: #228B22"># Start integrating using the Velocity-Verlet  method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up the acceleration</span>
    rabs = sqrt(<span style="color: #658b00">sum</span>(r[i]*r[i]))
    a =  -alpha*r[i]/(rabs**<span style="color: #B452CD">3</span>)
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*(DeltaT**<span style="color: #B452CD">2</span>)*a
    rabs = sqrt(<span style="color: #658b00">sum</span>(r[i+<span style="color: #B452CD">1</span>]*r[i+<span style="color: #B452CD">1</span>]))
    anew = -alpha*r[i+<span style="color: #B452CD">1</span>]/(rabs**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
    E[i+<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0.5</span>*m*(v[i+<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>]**<span style="color: #B452CD">2</span>+v[i+<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)-alpha/rabs
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
<span style="color: #228B22"># Plot position as function of time</span>
fig, ax = plt.subplots(<span style="color: #B452CD">3</span>,<span style="color: #B452CD">1</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;y&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;x&#39;</span>)
ax[<span style="color: #B452CD">0</span>].plot(r[:,<span style="color: #B452CD">0</span>],r[:,<span style="color: #B452CD">1</span>])
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_ylabel(<span style="color: #CD5555">&#39;y position&#39;</span>)
ax[<span style="color: #B452CD">1</span>].plot(t,r[:,<span style="color: #B452CD">0</span>])
ax[<span style="color: #B452CD">2</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">2</span>].set_ylabel(<span style="color: #CD5555">&#39;y position&#39;</span>)
ax[<span style="color: #B452CD">2</span>].plot(t,r[:,<span style="color: #B452CD">1</span>])

fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;2DimGravity&quot;</span>)
plt.show()
<span style="color: #658b00">print</span>(E)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Central forces are forces which are directed towards or away from a
reference point. A familiar force is the gravitional
force  with the motion of our Earth around the Sun as a classic. The Sun, being
approximately sixth order of magnitude heavier than the Earth serves
as our origin. A force like the gravitational force is a function of the
relative distance \( \boldsymbol{r}=\boldsymbol{r}_1-\boldsymbol{r}_2 \) only, where 
\( \boldsymbol{r}_1 \) and \( \boldsymbol{r}_2 \) are the positions relative to a defined
origin for object one and object two, respectively.
</p>

<p>These forces depend on the spatial degrees of freedom only (the
positions of the interacting objects/particles). As discussed earlier, from such forces we can infer
that  the total internal energy, the total linear momentum and total angular momentum are so-called constants of the motion, that is they stay constant  over time. We say that energy, linear and anuglar momentum are conserved.
</p>

<p>With a scalar potential \( V(\boldsymbol{r}) \) we define the force as the gradient of the potential</p>

<p>&nbsp;<br>
$$
\boldsymbol{F}(\boldsymbol{r})=-\boldsymbol{\nabla}V(\boldsymbol{r}).
$$
<p>&nbsp;<br>

<p>In general these potentials depend only on the magnitude of the
relative position and we will write the potential as \( V(r) \) where \( r \)
is defined as,
</p>

<p>&nbsp;<br>
$$
r = |\boldsymbol{r}_1-\boldsymbol{r}_2|.
$$
<p>&nbsp;<br>

<p>In three dimensions our vectors are defined as (for a given object/particle \( i \))</p>
<p>&nbsp;<br>
$$
\boldsymbol{r}_i = x_i\boldsymbol{e}_1+y_i\boldsymbol{e}_2+z_i\boldsymbol{e}_3,
$$
<p>&nbsp;<br>

<p>while in two dimensions we have</p>
<p>&nbsp;<br>
$$
\boldsymbol{r}_i = x_i\boldsymbol{e}_1+y_i\boldsymbol{e}_2.
$$
<p>&nbsp;<br>

<p>In two dimensions the radius \( r \) is defined as </p>
<p>&nbsp;<br>
$$
r = |\boldsymbol{r}_1-\boldsymbol{r}_2|=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}.
$$
<p>&nbsp;<br>

<p>If we consider the gravitational potential involving two masses \( 1 \) and \( 2 \), we have</p>
<p>&nbsp;<br>
$$
V_{12}(r)=V(r)=-\frac{Gm_1m_2}{|\boldsymbol{r}_1-\boldsymbol{r}_2|}=-\frac{Gm_1m_2}{r}.
$$
<p>&nbsp;<br>

<p>Calculating the gradient of this potential we obtain the force</p>
<p>&nbsp;<br>
$$
\boldsymbol{F}(\boldsymbol{r})=-\frac{Gm_1m_2}{|\boldsymbol{r}_1-\boldsymbol{r}_1|^2}\hat{\boldsymbol{r}}_{12}=-\frac{Gm_am_b}{r^2}\hat{\boldsymbol{r}},
$$
<p>&nbsp;<br>

<p>where we have the unit vector</p>
<p>&nbsp;<br>
$$
\hat{\boldsymbol{r}}=\hat{\boldsymbol{r}}_{12}=\frac{\boldsymbol{r}_2-\boldsymbol{r}_1}{|\boldsymbol{r}_1-\boldsymbol{r}_2|}.
$$
<p>&nbsp;<br>

<p>Here \( G=6.67\times 10^{-11} \) Nm$^2$/kg$^2$, and \( \boldsymbol{F} \) is the force
on \( 2 \) due to \( 1 \). By inspection, one can see that the force on \( 2 \)
due to \( 1 \) and the force on \( 1 \) due to \( 2 \) are equal and opposite. The
net potential energy for a large number of masses would be
</p>

<p>&nbsp;<br>
$$
V=\sum_{i < j}V_{ij}=\frac{1}{2}\sum_{i\ne j}V_{ij}.
$$
<p>&nbsp;<br>

<p>In general, the central forces that we will study can be written mathematically as</p>
<p>&nbsp;<br>
$$
\boldsymbol{F}(\boldsymbol{r})=f(r)\hat{r},
$$
<p>&nbsp;<br>

<p>where \( f(r) \) is  a scalar function. For the above gravitational force this scalar term is
\( -Gm_1m_2/r^2 \).
In general we will simply write this scalar function \( f(r)=\alpha/r^2 \) where \( \alpha \) is a constant that can be either negative or positive. We will also see examples of other types of potentials in the examples below.
</p>

<p>Besides general expressions for the potentials/forces, we will discuss
in detail different types of motion that arise, from circular to
elliptical or hyperbolic or parabolic. By transforming to either polar
coordinates or spherical coordinates, we will be able to obtain
analytical solutions for the equations of motion and thereby obtain
new insights about the properties of a system. Where possible, we will
compare our analytical equations with numerical studies.
</p>

<p>However, before we arrive at these lovely insights, we need to
introduce some mathematical manipulations and definitions. We conclude
this chapter with a discussion of two-body scattering.
</p>
<h2 id="center-of-mass-and-relative-coordinates">Center of Mass and Relative Coordinates </h2>

<p>Thus far, we have considered the trajectory as if the force is
centered around a fixed point. For two bodies interacting only with
one another, both masses circulate around the center of mass. One
might think that solutions would become more complex when both
particles move, but we will see here that the problem can be reduced
to one with a single body moving according to a fixed force by
expressing the trajectories for \( \boldsymbol{r}_1 \) and \( \boldsymbol{r}_2 \) into the
center-of-mass coordinate \( \boldsymbol{R} \) and the relative
coordinate \( \boldsymbol{r} \). We define the center-of-mass (CoM) coordinate as 
</p>

<p>&nbsp;<br>
$$
\boldsymbol{R}\equiv\frac{m_1\boldsymbol{r}_1+m_2\boldsymbol{r}_2}{m_1+m_2},
$$
<p>&nbsp;<br>

<p>and the relative coordinate as</p>
<p>&nbsp;<br>
$$
\boldsymbol{r}\equiv\boldsymbol{r}_1-\boldsymbol{r_2}.
$$
<p>&nbsp;<br>

<p>We can then rewrite \( \boldsymbol{r}_1 \) and \( \boldsymbol{r}_2 \) in terms of the relative and CoM coordinates as</p>

<p>&nbsp;<br>
$$
\boldsymbol{r}_1=\boldsymbol{R}+\frac{m_2}{M}\boldsymbol{r},
$$
<p>&nbsp;<br>

<p>and</p>

<p>&nbsp;<br>
$$
\boldsymbol{r}_2=\boldsymbol{R}-\frac{m_1}{M}\boldsymbol{r}.
$$
<p>&nbsp;<br>
<h3 id="conservation-of-total-linear-momentum">Conservation of total  Linear Momentum </h3>

<p>In our discussions on conservative forces we defined 
the total linear momentum as
</p>

<p>&nbsp;<br>
$$
\boldsymbol{P}=\sum_{i=1}^Nm_i\frac{d\boldsymbol{r}_i}{dt},
$$
<p>&nbsp;<br>

<p>where \( N=2 \) in our case. With the above definition of the center of mass position, we see that we can rewrite the total linear momentum as (multiplying the CoM coordinate  with \( M \))</p>

<p>&nbsp;<br>
$$
\boldsymbol{P}=M\frac{d\boldsymbol{R}}{dt}=M\dot{\boldsymbol{R}}.
$$
<p>&nbsp;<br>

<p>The net force acting on the system is given by the time derivative of the linear momentum (assuming mass is time independent)
and we have
</p>

<p>&nbsp;<br>
$$
\boldsymbol{F}^{\mathrm{net}}=\dot{\boldsymbol{P}}=M\ddot{\boldsymbol{R}}.
$$
<p>&nbsp;<br>

<p>The net force acting on the system is given by the sum of the forces acting on the two bodies, that is we have</p>

<p>&nbsp;<br>
$$
\boldsymbol{F}^{\mathrm{net}}=\boldsymbol{F}_1+\boldsymbol{F}_2=\dot{\boldsymbol{P}}=M\ddot{\boldsymbol{R}}.
$$
<p>&nbsp;<br>

<p>In our case the forces are given by the internal forces only. The force acting on object \( 1 \) is thus \( \boldsymbol{F}_{12} \) and the one acting on object \( 2 \) is \( \boldsymbol{F}_{12} \). We have also defined that \( \boldsymbol{F}_{12}=-\boldsymbol{F}_{21} \). This means thar we have</p>
<p>&nbsp;<br>
$$
\boldsymbol{F}_1+\boldsymbol{F}_2=\boldsymbol{F}_{12}+\boldsymbol{F}_{21}=0=\dot{\boldsymbol{P}}=M\ddot{\boldsymbol{R}}.
$$
<p>&nbsp;<br>

<p>We could alternatively had write this</p>
<p>&nbsp;<br>
$$
\ddot{\boldsymbol{R}}_{\rm cm}=\frac{1}{m_1+m_2}\left\{m_1\ddot{\boldsymbol{r}}_1+m_2\ddot{\boldsymbol{r}}_2\right\}=\frac{1}{m_1+m_2}\left\{\boldsymbol{F}_{12}+\boldsymbol{F}_{21}\right\}=0.
$$
<p>&nbsp;<br>

<p>This has the important consequence that the CoM velocity is a constant
of the motion. And since the total linear momentum is given by the
time-derivative of the CoM coordinate times the total mass
\( M=m_1+m_2 \), it means that linear momentum is also conserved.
Stated differently,  the center-of-mass coordinate
\( \boldsymbol{R} \) moves at a fixed velocity.
</p>

<p>This has also another important consequence for our forces. If we
assume that our force depends only on the relative coordinate, it
means that the gradient of the potential with respect to the center of
mass position is zero, that is
</p>
<p>&nbsp;<br>
$$
M\ddot{d\boldsymbol{R}}=-\boldsymbol{\nabla}_{\boldsymbol{R}}V =0!
$$
<p>&nbsp;<br>

<p>If we now switch to the equation of motion for the relative coordinate, we have </p>
<p>&nbsp;<br>
$$
\ddot{\boldsymbol{r}}=\ddot{\boldsymbol{r}}_1-\ddot{\boldsymbol{r}}_2=\left(\frac{\boldsymbol{F}_{12}}{m_1}-\frac{\boldsymbol{F}_{21}}{m_2}\right)=\left(\frac{1}{m_1}+\frac{1}{m_2}\right)\boldsymbol{F}_{12},
$$
<p>&nbsp;<br>

<p>which we can rewrite in terms of the reduced mass</p>
<p>&nbsp;<br>
$$
\mu=\frac{m_1m_2}{m_1+m_2},
$$
<p>&nbsp;<br>

<p>as</p>
<p>&nbsp;<br>
$$
\mu \ddot{\boldsymbol{r}}=\boldsymbol{F}_{12}.
$$
<p>&nbsp;<br>

<p>This has a very important consequence for our coming analysis of the equations of motion for the two-body problem.
Since the acceleration for the CoM coordinate is zero, we can now
treat the trajectory as a one-body problem where the mass is given by 
the reduced mass \( \mu \) plus a second trivial problem for the center of
mass. The reduced mass is especially convenient when one is
considering forces that depend only on the relative coordinate (like the Gravitational force or the electrostatic force between two charges)  because then for say the gravitational force we have
</p>

<p>&nbsp;<br>
$$
\mu \ddot{\boldsymbol{r}}=-\frac{Gm_1m_2}{r^2}\hat{\boldsymbol{r}}=-\frac{GM\mu}{r^2}\hat{\boldsymbol{r}},
$$
<p>&nbsp;<br>

<p>where we have defined \( M= m_1+m_2 \).  It means that the acceleration of the relative coordinate is</p>
<p>&nbsp;<br>
$$
\ddot{\boldsymbol{r}}=-\frac{GM}{r^2}\hat{\boldsymbol{r}},
$$
<p>&nbsp;<br>

<p>and we have that for the gravitational problem, the reduced mass then falls out and the
trajectory depends only on the total mass \( M \).
</p>

<p>The standard strategy is to transform into the center of mass frame,
then treat the problem as one of a single particle of mass \( \mu \)
undergoing a force \( \boldsymbol{F}_{12} \). Scattering angles, see our discussion of scattering problems below, can also be
expressed in this frame.  Before we proceed to our definition of the CoM frame we need to set up the expression for the energy in terms of the relative and CoM coordinates.
</p>
<h3 id="kinetic-and-total-energy">Kinetic and total Energy </h3>

<p>The kinetic energy and momenta also have analogues in center-of-mass
coordinates. 
We have defined the total linear momentum as 
</p>

<p>&nbsp;<br>
$$
\boldsymbol{P}=\sum_{i=1}^Nm_i\frac{d\boldsymbol{r}_i}{dt}=M\dot{\boldsymbol{R}}.
$$
<p>&nbsp;<br>

<p>For the relative momentum \( \boldsymbol{q} \), we have that the time derivative of \( \boldsymbol{r} \) is</p>
<p>&nbsp;<br>
$$
\dot{\boldsymbol{r}} =\dot{\boldsymbol{r}}_1-\dot{\boldsymbol{r}}_2,
$$
<p>&nbsp;<br>

<p>We know also that the momenta \( \boldsymbol{p}_1=m_1\dot{\boldsymbol{r}}_1 \) and
\( \boldsymbol{p}_2=m_2\dot{\boldsymbol{r}}_2 \). Using these expressions we can rewrite
</p>

<p>&nbsp;<br>
$$
\dot{\boldsymbol{r}} =\frac{\boldsymbol{p}_1}{m_1}-\frac{\boldsymbol{p}_2}{m_2},
$$
<p>&nbsp;<br>

<p>which gives</p>

<p>&nbsp;<br>
$$
\dot{\boldsymbol{r}} =\frac{m_2\boldsymbol{p}_1-m_1\boldsymbol{p}_2}{m_1m_2},
$$
<p>&nbsp;<br>

<p>and dividing both sides with \( M \) we have</p>

<p>&nbsp;<br>
$$
\frac{m_1m_2}{M}\dot{\boldsymbol{r}} =\frac{m_2\boldsymbol{p}_1-m_1\boldsymbol{p}_2}{M}.
$$
<p>&nbsp;<br>

<p>Introducing the reduced mass \( \mu=m_1m_2/M \) we have finally</p>

<p>&nbsp;<br>
$$
\mu\dot{\boldsymbol{r}} =\frac{m_2\boldsymbol{p}_1-m_1\boldsymbol{p}_2}{M}.
$$
<p>&nbsp;<br>

<p>And \( \mu\dot{\boldsymbol{r}} \) defines the relative momentum \( \boldsymbol{q}=\mu\dot{\boldsymbol{r}} \). </p>

<p>With these definitions we can then calculate the kinetic energy in terms of the relative and CoM coordinates.</p>

<p>We have that</p>

<p>&nbsp;<br>
$$
K=\frac{p_1^2}{2m_1}+\frac{p_2^2}{2m_2},
$$
<p>&nbsp;<br>

<p>and with \( \boldsymbol{p}_1=m_1\dot{\boldsymbol{r}}_1 \) and \( \boldsymbol{p}_2=m_2\dot{\boldsymbol{r}}_2 \) and using</p>

<p>&nbsp;<br>
$$
\dot{\boldsymbol{r}}_1=\dot{\boldsymbol{R}}+\frac{m_2}{M}\dot{\boldsymbol{r}},
$$
<p>&nbsp;<br>

<p>and</p>

<p>&nbsp;<br>
$$
\dot{\boldsymbol{r}}_2=\dot{\boldsymbol{R}}-\frac{m_1}{M}\dot{\boldsymbol{r}},
$$
<p>&nbsp;<br>

<p>we obtain after squaring the expressions for \( \dot{\boldsymbol{r}}_1 \) and \( \dot{\boldsymbol{r}}_2 \)</p>

<p>&nbsp;<br>
$$
K=\frac{(m_1+m_2)\dot{\boldsymbol{R}}^2}{2}+\frac{(m_1+m_2)m_1m_2\dot{\boldsymbol{r}}^2}{2M^2},
$$
<p>&nbsp;<br>

<p>which we simplify to </p>

<p>&nbsp;<br>
$$
K=\frac{\dot{\boldsymbol{P}}^2}{2M}+\frac{\mu\dot{\boldsymbol{q}}^2}{2}.
$$
<p>&nbsp;<br>

<p>Below we will define a reference frame, the so-called CoM-frame, where
\( \boldsymbol{R}=0 \). This is going to simplify our equations further.
</p>
<h3 id="conservation-of-angular-momentum">Conservation of Angular Momentum </h3>

<p>The angular momentum (the total one) is the sum of the individual angular momenta. In our case we have two bodies only, meaning that our angular momentum is defined as</p>

<p>&nbsp;<br>
$$
\boldsymbol{L} = \boldsymbol{r}_1 \times \boldsymbol{p}_1+\boldsymbol{r}_2 \times \boldsymbol{p}_2,
$$
<p>&nbsp;<br>

<p>and using that \( m_1\dot{\boldsymbol{r}}_1=\boldsymbol{p}_1 \) and \( m_2\dot{\boldsymbol{r}}_2=\boldsymbol{p}_2 \) we have</p>

<p>&nbsp;<br>
$$
\boldsymbol{L} = m_1\boldsymbol{r}_1 \times \dot{\boldsymbol{r}}_1+m_2\boldsymbol{r}_2 \times \dot{\boldsymbol{r}}_2.
$$
<p>&nbsp;<br>

<p>We define now the CoM-Frame where we set \( \boldsymbol{R}=0 \). This means that the equations 
for \( \boldsymbol{r}_1 \) and \( \boldsymbol{r}_2 \) in terms of the relative motion simplify and  we have
</p>
<p>&nbsp;<br>
$$
\boldsymbol{r}_1=\frac{m_2}{M}\boldsymbol{r},
$$
<p>&nbsp;<br>

<p>and</p>

<p>&nbsp;<br>
$$
\boldsymbol{r}_2=-\frac{m_1}{M}\boldsymbol{r}.
$$
<p>&nbsp;<br>

<p>resulting in </p>
<p>&nbsp;<br>
$$
\boldsymbol{L} = m_1 \frac{m_2}{M}\boldsymbol{r}\times\frac{m_2}{M}\boldsymbol{r} +m_2 \frac{m_1}{M}\boldsymbol{r} \times \frac{m_1}{M}\dot{\boldsymbol{r}}.
$$
<p>&nbsp;<br>

<p>We see that can rewrite this equation as </p>
<p>&nbsp;<br>
$$
\boldsymbol{L}=\boldsymbol{r}\times \mu\dot{\boldsymbol{r}}=\mu\boldsymbol{r}\times \dot{\boldsymbol{r}}.
$$
<p>&nbsp;<br>

<p>If we now use a central force, we have that</p>
<p>&nbsp;<br>
$$
\mu\dot{\boldsymbol{r}}=\boldsymbol{F}(\boldsymbol{r})=f(r)\hat{\boldsymbol{r}}, 
$$
<p>&nbsp;<br>

<p>and inserting this in the equation for the angular momentum we have</p>
<p>&nbsp;<br>
$$
\boldsymbol{L}=\boldsymbol{r}\times f(r)\hat{\boldsymbol{r}},
$$
<p>&nbsp;<br>

<p>which equals zero since we are taking the cross product of the vector
\( \boldsymbol{r} \) with itself.  Angular momentum is thus conserved and in
addition to the total linear momentum being conserved, we know that
energy is also conserved with forces that depend only on position and
the relative coordinate only.
</p>

<p>Since angular momentum is conserved, we can idealize
the motion of our two objects as two bodies moving in a plane spanned by the
relative coordinate and the relative momentum. The angular
momentum is perpendicular to the plane spanned by these two vectors.
</p>

<p>It means also, since \( \boldsymbol{L} \) is conserved, that we can reduce our
problem to a motion in say the \( xy \)-plane.  What we have done then is to
reduce a two-body problem in three-dimensions with six degrees of
freedom (the six coordinates of the two objects) to a problem defined
entirely by the relative coordinate in two dimensions.  We have thus
moved from a problem with six degrees of freedom to one with two degrees of freedom only.
</p>

<p>Since we deal with central forces that depend only on the
relative coordinate, we will show below that transforming to polar
coordinates, we cna find analytical solution to
the equation of motion
</p>
<p>&nbsp;<br>
$$
\mu\dot{\boldsymbol{r}}=\boldsymbol{F}(\boldsymbol{r})=f(r)\hat{\boldsymbol{r}}.
$$
<p>&nbsp;<br>

<p>Note the boldfaced symbols for the relative position \( \boldsymbol{r} \). Our vector \( \boldsymbol{r} \) is defined as</p>

<p>&nbsp;<br>
$$
\boldsymbol{r}=x\boldsymbol{e}_1+y\boldsymbol{e}_2
$$
<p>&nbsp;<br>

<p>and introducing polar coordinates \( r\in[0,\infty) \) and \( \phi\in [0,2\pi] \) and the transformation </p>
<p>&nbsp;<br>
$$
r=\sqrt{x^2+y^2},
$$
<p>&nbsp;<br>

<p>and \( x=r\cos\phi \) and \( y=r\sin\phi \), we will rewrite our equation of motion by transforming from Cartesian coordinates to Polar coordinates. By so doing, we end up with two differential equations which can be solved analytically (it depends on the form of the potential).</p>

<p>What follows now is a rewrite of these equations and the introduction of Kepler's laws as well.</p>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

  // Display navigation controls in the bottom right corner
  controls: true,

  // Display progress bar (below the horiz. slider)
  progress: true,

  // Display the page number of the current slide
  slideNumber: true,

  // Push each slide change to the browser history
  history: false,

  // Enable keyboard shortcuts for navigation
  keyboard: true,

  // Enable the slide overview mode
  overview: true,

  // Vertical centering of slides
  //center: true,
  center: false,

  // Enables touch navigation on devices with touch input
  touch: true,

  // Loop the presentation
  loop: false,

  // Change the presentation direction to be RTL
  rtl: false,

  // Turns fragments on and off globally
  fragments: true,

  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,

  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,

  // Stop auto-sliding after user input
  autoSlideStoppable: true,

  // Enable slide navigation via mouse wheel
  mouseWheel: false,

  // Hides the address bar on mobile devices
  hideAddressBar: true,

  // Opens links in an iframe preview overlay
  previewLinks: false,

  // Transition style
  transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Transition speed
  transitionSpeed: 'default', // default/fast/slow

  // Transition style for full page slide backgrounds
  backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

  // Number of slides away from the current that are visible
  viewDistance: 3,

  // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

  // Parallax background size
  //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

  theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
  dependencies: [
      // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

      // Interpret Markdown in <section> elements
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

      // Syntax highlight for <code> elements
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

      // Zoom in and out with Alt+click
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

      // Speaker notes
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

      // Remote control your reveal.js presentation using a touch device
      //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

      // MathJax
      //{ src: 'reveal.js/plugin/math/math.js', async: true }
  ]
});

Reveal.initialize({

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1170,  // original: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
   end footer logo -->




</body>
</html>

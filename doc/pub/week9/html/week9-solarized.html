<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week9.do.txt --pygments_html_style=perldoc --html_style=solarized3 --html_links_in_new_window --html_output=week9-solarized --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="PHY321: Harmonic Oscillations, Damping, Resonances and time-dependent Forces">
<title>PHY321: Harmonic Oscillations, Damping, Resonances and time-dependent Forces</title>
<link href="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<link href="https://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Aims and Overarching Motivation',
               2,
               None,
               'aims-and-overarching-motivation'),
              ('Monday, February 27', 3, None, 'monday-february-27'),
              ('Wednesday, March 1', 3, None, 'wednesday-march-1'),
              ('Friday, March 3', 3, None, 'friday-march-3'),
              ('Damped Oscillators', 2, None, 'damped-oscillators'),
              ('Harmonic Oscillator,  Damping',
               2,
               None,
               'harmonic-oscillator-damping'),
              ('Harmonic Oscillator,  Solutions of Damped Motion',
               2,
               None,
               'harmonic-oscillator-solutions-of-damped-motion'),
              ('Underdamped: $\\beta<\\omega_0$',
               2,
               None,
               'underdamped-beta-omega-0'),
              ('Critical dampling: $\\beta=\\omega_0$',
               2,
               None,
               'critical-dampling-beta-omega-0'),
              ('Overdamped: $\\beta>\\omega_0$',
               2,
               None,
               'overdamped-beta-omega-0'),
              ('Harmonic Oscillator,  Solutions',
               2,
               None,
               'harmonic-oscillator-solutions'),
              ('Harmonic Oscillator,  Particular Solution',
               2,
               None,
               'harmonic-oscillator-particular-solution'),
              ('Solving with Driven Oscillations',
               2,
               None,
               'solving-with-driven-oscillations'),
              ('Alternative Derivation for Driven Oscillators',
               2,
               None,
               'alternative-derivation-for-driven-oscillators'),
              ('Damped and Driven Oscillator',
               2,
               None,
               'damped-and-driven-oscillator'),
              ('Resonance Widths; the $Q$ factor',
               2,
               None,
               'resonance-widths-the-q-factor'),
              ('Numerical Studies of Driven Oscillations',
               2,
               None,
               'numerical-studies-of-driven-oscillations'),
              ('Differential Equations, Runge-Kutta methods',
               2,
               None,
               'differential-equations-runge-kutta-methods')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- ------------------- main content ---------------------- -->
<center>
<h1>PHY321: Harmonic Oscillations, Damping, Resonances and time-dependent Forces</h1>
</center>  <!-- document title -->

<!-- author(s): <a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a> -->
<center>
<b><a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a></b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics and Astronomy and Facility for Rare Ion Beams (FRIB), Michigan State University, USA</b>
</center>
<center>
[2] <b>Department of Physics, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>Dec 23, 2022</h4>
</center> <!-- date -->
<br>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="aims-and-overarching-motivation">Aims and Overarching Motivation </h2>
<h3 id="monday-february-27">Monday, February 27 </h3>

<p>Damped oscillations. Analytical and numerical solutions.
<b>Reading suggestion</b>: Taylor sections 5.4-5.5. See also slides from last week.
</p>
<h3 id="wednesday-march-1">Wednesday, March 1 </h3>

<p>Driven oscillations and resonances with examples. Discussion of first midterm. First part of Wednesday is a regular lecture. The second half is dedicated to the midterm.</p>

<p><b>Reading suggestion</b>: Taylor sections 5.5-5.6. </p>
<h3 id="friday-march-3">Friday, March 3 </h3>

<p>Work on first midterm. Then spring break!</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="damped-oscillators">Damped Oscillators </h2>

<p>We consider only the case where the damping force is proportional to
the velocity. This is counter to dragging friction, where the force is
proportional in strength to the normal force and independent of
velocity, and is also inconsistent with wind resistance, where the
magnitude of the drag force is proportional the square of the
velocity. Rolling resistance does seem to be mainly proportional to
the velocity. However, the main motivation for considering damping
forces proportional to the velocity is that the math is more
friendly. This is because the differential equation is linear,
i.e. each term is of order \( x \), \( \dot{x} \), \( \ddot{x}\cdots \), or even
terms with no mention of \( x \), and there are no terms such as \( x^2 \) or
\( x\ddot{x} \). The equations of motion for a spring with damping force
\( -b\dot{x} \) are
</p>

$$
\begin{equation}
m\ddot{x}+b\dot{x}+kx=0.
\label{_auto1}
\end{equation}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="harmonic-oscillator-damping">Harmonic Oscillator,  Damping </h2>

<p>Just to make the solution a bit less messy, we rewrite this equation as</p>

$$
\begin{equation}
\label{eq:dampeddiffyq}
\ddot{x}+2\beta\dot{x}+\omega_0^2x=0,~~~~\beta\equiv b/2m,~\omega_0\equiv\sqrt{k/m}.
\end{equation}
$$

<p>Both \( \beta \) and \( \omega \) have dimensions of inverse time. To find solutions (see appendix C in the text) you must make an educated guess at the form of the solution. To do this, first realize that the solution will need an arbitrary normalization \( A \) because the equation is linear. Secondly, realize that if the form is</p>

$$
\begin{equation}
x=Ae^{rt}
\label{_auto2}
\end{equation}
$$

<p>that each derivative simply brings out an extra power of \( r \). This
means that the \( Ae^{rt} \) factors out and one can simply solve for an
equation for \( r \). Plugging this form into Eq. \eqref{eq:dampeddiffyq},
</p>

$$
\begin{equation}
r^2+2\beta r+\omega_0^2=0.
\label{_auto3}
\end{equation}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="harmonic-oscillator-solutions-of-damped-motion">Harmonic Oscillator,  Solutions of Damped Motion </h2>

<p>Because this is a quadratic equation there will be two solutions,</p>

$$
\begin{equation}
r=-\beta\pm\sqrt{\beta^2-\omega_0^2}.
\label{_auto4}
\end{equation}
$$

<p>We refer to the two solutions as \( r_1 \) and \( r_2 \) corresponding to the
\( + \) and \( - \) roots. As expected, there should be two arbitrary
constants involved in the solution,
</p>

$$
\begin{equation}
x=A_1e^{r_1t}+A_2e^{r_2t},
\label{_auto5}
\end{equation}
$$

<p>where the coefficients \( A_1 \) and \( A_2 \) are determined by initial
conditions.
</p>

<p>The roots listed above, \( \sqrt{\omega_0^2-\beta_0^2} \), will be
imaginary if the damping is small and \( \beta < \omega_0 \). In that case,
\( r \) is complex and the factor \( \exp{(rt)} \) will have some oscillatory
behavior. If the roots are real, there will only be exponentially
decaying solutions. There are three cases:
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="underdamped-beta-omega-0">Underdamped: \( \beta < \omega_0 \) </h2>

$$
\begin{eqnarray}
x&=&A_1e^{-\beta t}e^{i\omega't}+A_2e^{-\beta t}e^{-i\omega't},~~\omega'\equiv\sqrt{\omega_0^2-\beta^2}\\
\nonumber
&=&(A_1+A_2)e^{-\beta t}\cos\omega't+i(A_1-A_2)e^{-\beta t}\sin\omega't.
\end{eqnarray}
$$

<p>Here we have made use of the identity
\( e^{i\omega't}=\cos\omega't+i\sin\omega't \). Because the constants are
arbitrary, and because the real and imaginary parts are both solutions
individually, we can simply consider the real part of the solution
alone:
</p>

$$
\begin{eqnarray}
\label{eq:homogsolution}
x&=&B_1e^{-\beta t}\cos\omega't+B_2e^{-\beta t}\sin\omega't,\\
\nonumber 
\omega'&\equiv&\sqrt{\omega_0^2-\beta^2}.
\end{eqnarray}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="critical-dampling-beta-omega-0">Critical dampling: \( \beta=\omega_0 \) </h2>

<p>In this case the two terms involving \( r_1 \) and \( r_2 \) are identical
because \( \omega'=0 \). Because we need to arbitrary constants, there
needs to be another solution. This is found by simply guessing, or by
taking the limit of \( \omega'\rightarrow 0 \) from the underdamped
solution. The solution is then
</p>

$$
\begin{equation}
\label{eq:criticallydamped}
x=Ae^{-\beta t}+Bte^{-\beta t}.
\end{equation}
$$

<p>The critically damped solution is interesting because the solution
approaches zero quickly, but does not oscillate. For a problem with
zero initial velocity, the solution never crosses zero. This is a good
choice for designing shock absorbers or swinging doors.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="overdamped-beta-omega-0">Overdamped: \( \beta>\omega_0 \) </h2>

$$
\begin{eqnarray}
x&=&A_1\exp{-(\beta+\sqrt{\beta^2-\omega_0^2})t}+A_2\exp{-(\beta-\sqrt{\beta^2-\omega_0^2})t}
\end{eqnarray}
$$

<p>This solution will also never pass the origin more than once, and then
only if the initial velocity is strong and initially toward zero.
</p>

<p>Given \( b \), \( m \) and \( \omega_0 \), find \( x(t) \) for a particle whose
initial position is \( x=0 \) and has initial velocity \( v_0 \) (assuming an
underdamped solution).
</p>

<p>The solution is of the form,</p>

$$
\begin{eqnarray*}
x&=&e^{-\beta t}\left[A_1\cos(\omega' t)+A_2\sin\omega't\right],\\
\dot{x}&=&-\beta x+\omega'e^{-\beta t}\left[-A_1\sin\omega't+A_2\cos\omega't\right].\\
\omega'&\equiv&\sqrt{\omega_0^2-\beta^2},~~~\beta\equiv b/2m.
\end{eqnarray*}
$$

<p>From the initial conditions, \( A_1=0 \) because \( x(0)=0 \) and \( \omega'A_2=v_0 \). So </p>

$$
x=\frac{v_0}{\omega'}e^{-\beta t}\sin\omega't.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="harmonic-oscillator-solutions">Harmonic Oscillator,  Solutions </h2>

<p>Consider a single solution with no arbitrary constants, which we will
call a <b>particular solution</b>, \( x_p(t) \). It should be emphasized
that this is <b>A</b> particular solution, because there exists an
infinite number of such solutions because the general solution should
have two arbitrary constants. Now consider solutions to the same
equation without the driving term, which include two arbitrary
constants. These are called either <b>homogenous solutions</b> or 
<b>complementary solutions</b>, and were given above, 
e.g. Eq. \eqref{eq:homogsolution} for the underdamped case. The
homogenous solution already incorporates the two arbitrary constants,
so any sum of a homogenous solution and a particular solution will
represent the <b>general solution</b> of the equation. The general
solution incorporates the two arbitrary constants \( A \) and \( B \) to
accommodate the two initial conditions. One could have picked a
different particular solution, i.e. the original particular solution
plus any homogenous solution with the arbitrary constants \( A_p \) and
\( B_p \) chosen at will. When one adds in the homogenous solution, which
has adjustable constants with arbitrary constants \( A' \) and \( B' \), to
the new particular solution, one can get the same general solution by
simply adjusting the new constants such that \( A'+A_p=A \) and
\( B'+B_p=B \). Thus, the choice of \( A_p \) and \( B_p \) are irrelevant, and
when choosing the particular solution it is best to make the simplest
choice possible.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="harmonic-oscillator-particular-solution">Harmonic Oscillator,  Particular Solution </h2>

<p>To find a particular solution, one first guesses at the form,</p>

$$
\begin{equation}
\label{eq:partform}
x_p(t)=D\cos(\omega t-\delta),
\end{equation}
$$

<p>and rewrite the differential equation as</p>

$$
\begin{equation}
D\left\{-\omega^2\cos(\omega t-\delta)-2\beta\omega\sin(\omega t-\delta)+\omega_0^2\cos(\omega t-\delta)\right\}=\frac{F_0}{m}\cos(\omega t).
\label{_auto6}
\end{equation}
$$

<p>One can now use angle addition formulas to get</p>

$$
\begin{eqnarray}
D\left\{(-\omega^2\cos\delta+2\beta\omega\sin\delta+\omega_0^2\cos\delta)\cos(\omega t)\right.&&\\
\nonumber
\left.+(-\omega^2\sin\delta-2\beta\omega\cos\delta+\omega_0^2\sin\delta)\sin(\omega t)\right\}
&=&\frac{F_0}{m}\cos(\omega t).
\end{eqnarray}
$$

<p>Both the \( \cos \) and \( \sin \) terms need to equate if the expression is to hold at all times. Thus, this becomes two equations</p>

$$
\begin{eqnarray}
D\left\{-\omega^2\cos\delta+2\beta\omega\sin\delta+\omega_0^2\cos\delta\right\}&=&\frac{F_0}{m}\\
\nonumber
-\omega^2\sin\delta-2\beta\omega\cos\delta+\omega_0^2\sin\delta&=&0.
\end{eqnarray}
$$

<p>After dividing by \( \cos\delta \), the lower expression leads to</p>

$$
\begin{equation}
\tan\delta=\frac{2\beta\omega}{\omega_0^2-\omega^2}.
\label{_auto7}
\end{equation}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="solving-with-driven-oscillations">Solving with Driven Oscillations </h2>

<p>Using the identities \( \tan^2+1=\csc^2 \) and \( \sin^2+\cos^2=1 \), one can also express \( \sin\delta \) and \( \cos\delta \),</p>

$$
\begin{eqnarray}
\sin\delta&=&\frac{2\beta\omega}{\sqrt{(\omega_0^2-\omega^2)^2+4\omega^2\beta^2}},\\
\nonumber
\cos\delta&=&\frac{(\omega_0^2-\omega^2)}{\sqrt{(\omega_0^2-\omega^2)^2+4\omega^2\beta^2}}
\end{eqnarray}
$$

<p>Inserting the expressions for \( \cos\delta \) and \( \sin\delta \) into the expression for \( D \),</p>

$$
\begin{equation}
\label{eq:Ddrive}
D=\frac{F_0/m}{\sqrt{(\omega_0^2-\omega^2)^2+4\omega^2\beta^2}}.
\end{equation}
$$

<p>For a given initial condition, e.g. initial displacement and velocity,
one must add the homogenous solution then solve for the two arbitrary
constants. However, because the homogenous solutions decay with time
as \( e^{-\beta t} \), the particular solution is all that remains at
large times, and is therefore the steady state solution. Because the
arbitrary constants are all in the homogenous solution, all memory of
the initial conditions are lost at large times, \( t>>1/\beta \).
</p>

<p>The amplitude of the motion, \( D \), is linearly proportional to the
driving force (\( F_0/m \)), but also depends on the driving frequency
\( \omega \). For small \( \beta \) the maximum will occur at
\( \omega=\omega_0 \). This is referred to as a resonance. In the limit
\( \beta\rightarrow 0 \) the amplitude at resonance approaches infinity.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="alternative-derivation-for-driven-oscillators">Alternative Derivation for Driven Oscillators </h2>

<p>Here, we derive the same expressions as in Equations \eqref{eq:partform} and \eqref{eq:Ddrive} but express the driving forces as</p>

$$
\begin{eqnarray}
F(t)&=&F_0e^{i\omega t},
\end{eqnarray}
$$

<p>rather than as \( F_0\cos\omega t \). The real part of \( F \) is the same as before. For the differential equation,</p>

$$
\begin{eqnarray}
\label{eq:compdrive}
\ddot{x}+2\beta\dot{x}+\omega_0^2x&=&\frac{F_0}{m}e^{i\omega t},
\end{eqnarray}
$$

<p>one can treat \( x(t) \) as an imaginary function. Because the operations
\( d^2/dt^2 \) and \( d/dt \) are real and thus do not mix the real and
imaginary parts of \( x(t) \), Eq. \eqref{eq:compdrive} is effectively 2
equations. Because \( e^{\omega t}=\cos\omega t+i\sin\omega t \), the real
part of the solution for \( x(t) \) gives the solution for a driving force
\( F_0\cos\omega t \), and the imaginary part of \( x \) corresponds to the
case where the driving force is \( F_0\sin\omega t \). It is rather easy
to solve for the complex \( x \) in this case, and by taking the real part
of the solution, one finds the answer for the \( \cos\omega t \) driving
force.
</p>

<p>We assume a simple form for the particular solution</p>

$$
\begin{equation}
x_p=De^{i\omega t},
\label{_auto8}
\end{equation}
$$

<p>where \( D \) is a complex constant.</p>

<p>From Eq. \eqref{eq:compdrive} one inserts the form for \( x_p \) above to get</p>

$$
\begin{eqnarray}
D\left\{-\omega^2+2i\beta\omega+\omega_0^2\right\}e^{i\omega t}=(F_0/m)e^{i\omega t},\\
\nonumber
D=\frac{F_0/m}{(\omega_0^2-\omega^2)+2i\beta\omega}.
\end{eqnarray}
$$

<p>The norm and phase for \( D=|D|e^{-i\delta} \) can be read by inspection,</p>

$$
\begin{equation}
|D|=\frac{F_0/m}{\sqrt{(\omega_0^2-\omega^2)^2+4\beta^2\omega^2}},~~~~\tan\delta=\frac{2\beta\omega}{\omega_0^2-\omega^2}.
\label{_auto9}
\end{equation}
$$

<p>This is the same expression for \( \delta \) as before. One then finds \( x_p(t) \),</p>

$$
\begin{eqnarray}
\label{eq:fastdriven1}
x_p(t)&=&\Re\frac{(F_0/m)e^{i\omega t-i\delta}}{\sqrt{(\omega_0^2-\omega^2)^2+4\beta^2\omega^2}}\\
\nonumber
&=&\frac{(F_0/m)\cos(\omega t-\delta)}{\sqrt{(\omega_0^2-\omega^2)^2+4\beta^2\omega^2}}.
\end{eqnarray}
$$

<p>This is the same answer as before.
If one wished to solve for the case where \( F(t)= F_0\sin\omega t \), the imaginary part of the solution would work
</p>

$$
\begin{eqnarray}
\label{eq:fastdriven2}
x_p(t)&=&\Im\frac{(F_0/m)e^{i\omega t-i\delta}}{\sqrt{(\omega_0^2-\omega^2)^2+4\beta^2\omega^2}}\\
\nonumber
&=&\frac{(F_0/m)\sin(\omega t-\delta)}{\sqrt{(\omega_0^2-\omega^2)^2+4\beta^2\omega^2}}.
\end{eqnarray}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="damped-and-driven-oscillator">Damped and Driven Oscillator  </h2>

<p>Consider the damped and driven harmonic oscillator worked out above. Given \( F_0, m,\beta \) and \( \omega_0 \), solve for the complete solution \( x(t) \) for the case where \( F=F_0\sin\omega t \) with initial conditions \( x(t=0)=0 \) and \( v(t=0)=0 \). Assume the underdamped case.</p>

<p>The general solution including the arbitrary constants includes both the homogenous and particular solutions,</p>

$$
\begin{eqnarray*}
x(t)&=&\frac{F_0}{m}\frac{\sin(\omega t-\delta)}{\sqrt{(\omega_0^2-\omega^2)^2+4\beta^2\omega^2}}
+A\cos\omega't e^{-\beta t}+B\sin\omega't e^{-\beta t}.
\end{eqnarray*}
$$

<p>The quantities \( \delta \) and \( \omega' \) are given earlier, \( \omega'=\sqrt{\omega_0^2-\beta^2},
\delta=\tan^{-1}(2\beta\omega/(\omega_0^2-\omega^2) \). Here, solving
the problem means finding the arbitrary constants \( A \) and
\( B \). Satisfying the initial conditions for the initial position and
velocity:
</p>

$$
\begin{eqnarray*}
x(t=0)=0&=&-\eta\sin\delta+A,\\
v(t=0)=0&=&\omega\eta\cos\delta-\beta A+\omega'B,\\
\eta&\equiv&\frac{F_0}{m}\frac{1}{\sqrt{(\omega_0^2-\omega^2)^2+4\beta^2\omega^2}}.
\end{eqnarray*}
$$

<p>The problem is now reduced to 2 equations and 2 unknowns, \( A \) and \( B \). The solution is</p>

$$
\begin{eqnarray}
A&=& \eta\sin\delta ,~~~B=\frac{-\omega\eta\cos\delta+\beta\eta\sin\delta}{\omega'}.
\end{eqnarray}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="resonance-widths-the-q-factor">Resonance Widths; the \( Q \) factor </h2>

<p>From above, the particular solution for a driving force, \( F=F_0\cos\omega t \), is</p>

$$
\begin{eqnarray}
x_p(t)&=&\frac{F_0/m}{\sqrt{(\omega_0^2-\omega^2)^2+4\omega^2\beta^2}}\cos(\omega_t-\delta),\\
\nonumber
\delta&=&\tan^{-1}\left(\frac{2\beta\omega}{\omega_0^2-\omega^2}\right).
\end{eqnarray}
$$

<p>If one fixes the driving frequency \( \omega \) and adjusts the
fundamental frequency \( \omega_0=\sqrt{k/m} \), the maximum amplitude
occurs when \( \omega_0=\omega \) because that is when the term from the
denominator \( (\omega_0^2-\omega^2)^2+4\omega^2\beta^2 \) is at a
minimum. This is akin to dialing into a radio station. However, if one
fixes \( \omega_0 \) and adjusts the driving frequency one minimize with
respect to \( \omega \), e.g. set
</p>

$$
\begin{equation}
\frac{d}{d\omega}\left[(\omega_0^2-\omega^2)^2+4\omega^2\beta^2\right]=0,
\label{_auto10}
\end{equation}
$$

<p>and one finds that the maximum amplitude occurs when
\( \omega=\sqrt{\omega_0^2-2\beta^2} \). If \( \beta \) is small relative to
\( \omega_0 \), one can simply state that the maximum amplitude is
</p>

$$
\begin{equation}
x_{\rm max}\approx\frac{F_0}{2m\beta \omega_0}.
\label{_auto11}
\end{equation}
$$


$$
\begin{eqnarray}
\frac{4\omega^2\beta^2}{(\omega_0^2-\omega^2)^2+4\omega^2\beta^2}=\frac{1}{2}.
\end{eqnarray}
$$

<p>For small damping this occurs when \( \omega=\omega_0\pm \beta \), so the \( FWHM\approx 2\beta \). For the purposes of tuning to a specific frequency, one wants the width to be as small as possible. The ratio of \( \omega_0 \) to \( FWHM \) is known as the <a href="https://en.wikipedia.org/wiki/Q_factor" target="_blank">quality factor</a>, or \( Q \) factor,</p>

$$
\begin{equation}
Q\equiv \frac{\omega_0}{2\beta}.
\label{_auto12}
\end{equation}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="numerical-studies-of-driven-oscillations">Numerical Studies of Driven Oscillations </h2>

<p>Solving the problem of driven oscillations numerically gives us much
more flexibility to study different types of driving forces. We can
reuse our earlier code by simply adding a driving force. If we stay in
the \( x \)-direction only this can be easily done by adding a term
\( F_{\mathrm{ext}}(x,t) \). Note that we have kept it rather general
here, allowing for both a spatial and a temporal dependence.
</p>

<p>Before we dive into the code, we need to briefly remind ourselves
about the equations we started with for the case with damping, namely
</p>

$$
m\frac{d^2x}{dt^2} + b\frac{dx}{dt}+kx(t) =0,
$$

<p>with no external force applied to the system.</p>

<p>Let us now for simplicty assume that our external force is given by</p>

$$
F_{\mathrm{ext}}(t) = F_0\cos{(\omega t)},
$$

<p>where \( F_0 \) is a constant (what is its dimension?) and \( \omega \) is the frequency of the applied external driving force.
<b>Small question:</b> would you expect energy to be conserved now?
</p>

<p>Introducing the external force into our lovely differential equation
and dividing by \( m \) and introducing \( \omega_0^2=\sqrt{k/m} \) we have
</p>
$$
\frac{d^2x}{dt^2} + \frac{b}{m}\frac{dx}{dt}+\omega_0^2x(t) =\frac{F_0}{m}\cos{(\omega t)},
$$

<p>Thereafter we introduce a dimensionless time \( \tau = t\omega_0 \)
and a dimensionless frequency \( \tilde{\omega}=\omega/\omega_0 \). We have then
</p>
$$
\frac{d^2x}{d\tau^2} + \frac{b}{m\omega_0}\frac{dx}{d\tau}+x(\tau) =\frac{F_0}{m\omega_0^2}\cos{(\tilde{\omega}\tau)},
$$

<p>Introducing a new amplitude \( \tilde{F} =F_0/(m\omega_0^2) \) (check dimensionality again) we have</p>
$$
\frac{d^2x}{d\tau^2} + \frac{b}{m\omega_0}\frac{dx}{d\tau}+x(\tau) =\tilde{F}\cos{(\tilde{\omega}\tau)}.
$$

<p>Our final step, as we did in the case of various types of damping, is
to define \( \gamma = b/(2m\omega_0) \) and rewrite our equations as
</p>
$$
\frac{d^2x}{d\tau^2} + 2\gamma\frac{dx}{d\tau}+x(\tau) =\tilde{F}\cos{(\tilde{\omega}\tau)}.
$$

<p>This is the equation we will code below using the Euler-Cromer method. </p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)


<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">pylab</span> <span style="color: #8B008B; font-weight: bold">import</span> plt, mpl
plt.style.use(<span style="color: #CD5555">&#39;seaborn&#39;</span>)
mpl.rcParams[<span style="color: #CD5555">&#39;font.family&#39;</span>] = <span style="color: #CD5555">&#39;serif&#39;</span>

DeltaT = <span style="color: #B452CD">0.001</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">20</span> <span style="color: #228B22"># in dimensionless time</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v, and x</span>
t = np.zeros(n)
v = np.zeros(n)
x = np.zeros(n)
<span style="color: #228B22"># Initial conditions as one-dimensional arrays of time</span>
x0 =  <span style="color: #B452CD">1.0</span> 
v0 = <span style="color: #B452CD">0.0</span>
x[<span style="color: #B452CD">0</span>] = x0
v[<span style="color: #B452CD">0</span>] = v0
gamma = <span style="color: #B452CD">0.2</span>
Omegatilde = <span style="color: #B452CD">0.5</span>
Ftilde = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Start integrating using Euler-Cromer&#39;s method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up the acceleration</span>
    <span style="color: #228B22"># Here you could have defined your own function for this</span>
    a =  -<span style="color: #B452CD">2</span>*gamma*v[i]-x[i]+Ftilde*cos(t[i]*Omegatilde)
    <span style="color: #228B22"># update velocity, time and position</span>
    v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*a
    x[i+<span style="color: #B452CD">1</span>] = x[i] + DeltaT*v[i+<span style="color: #B452CD">1</span>]
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
<span style="color: #228B22"># Plot position as function of time    </span>
fig, ax = plt.subplots()
ax.set_ylabel(<span style="color: #CD5555">&#39;x[m]&#39;</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;t[s]&#39;</span>)
ax.plot(t, x)
fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;ForcedBlockEulerCromer&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>In the above example we have focused on the Euler-Cromer method. This
method has a local truncation error which is proportional to \( \Delta t^2 \)
and thereby a global error which is proportional to \( \Delta t \).
We can improve this by using the Runge-Kutta family of
methods. The widely popular Runge-Kutta to fourth order or just <b>RK4</b>
has indeed a much better truncation error. The RK4 method has a global
error which is proportional to \( \Delta t \).
</p>

<p>Let us revisit this method and see how we can implement it for the above example.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="differential-equations-runge-kutta-methods">Differential Equations, Runge-Kutta methods </h2>

<p>Runge-Kutta (RK) methods are based on Taylor expansion formulae, but yield
in general better algorithms for solutions of an ordinary differential equation.
The basic philosophy is that it provides an intermediate step in the computation of \( y_{i+1} \).
</p>

<p>To see this, consider first the following definitions</p>
$$
\begin{equation}
\frac{dy}{dt}=f(t,y),  
\label{_auto13}
\end{equation} 
$$

<p>and </p>
$$
\begin{equation}
y(t)=\int f(t,y) dt,  
\label{_auto14}
\end{equation} 
$$

<p>and </p>
$$
\begin{equation}
y_{i+1}=y_i+ \int_{t_i}^{t_{i+1}} f(t,y) dt.
\label{_auto15}
\end{equation}
$$

<p>To demonstrate the philosophy behind RK methods, let us consider
the second-order RK method, RK2.
The first approximation consists in Taylor expanding \( f(t,y) \)
around the center of the integration interval \( t_i \) to \( t_{i+1} \),
that is, at \( t_i+h/2 \), \( h \) being the step.
Using the midpoint formula for an integral, 
defining \( y(t_i+h/2) = y_{i+1/2} \) and   
\( t_i+h/2 = t_{i+1/2} \), we obtain
</p>
$$
\begin{equation}
\int_{t_i}^{t_{i+1}} f(t,y) dt \approx hf(t_{i+1/2},y_{i+1/2}) +O(h^3).
\label{_auto16}
\end{equation} 
$$

<p>This means in turn that we have</p>
$$
\begin{equation}
y_{i+1}=y_i + hf(t_{i+1/2},y_{i+1/2}) +O(h^3).
\label{_auto17}
\end{equation}
$$

<p>However, we do not know the value of   \( y_{i+1/2} \). Here comes thus the next approximation, namely, we use Euler's
method to approximate \( y_{i+1/2} \). We have then
</p>
$$
\begin{equation}
y_{(i+1/2)}=y_i + \frac{h}{2}\frac{dy}{dt}=y(t_i) + \frac{h}{2}f(t_i,y_i).
\label{_auto18}
\end{equation}
$$

<p>This means that we can define the following algorithm for 
the second-order Runge-Kutta method, RK2.
</p>
$$
\begin{equation} 
k_1=hf(t_i,y_i),
\label{_auto19}
\end{equation} 
$$

$$
\begin{equation}
k_2=hf(t_{i+1/2},y_i+k_1/2),
\label{_auto20}
\end{equation}
$$

<p>with the final value</p>
$$
\begin{equation} 
y_{i+i}\approx y_i + k_2 +O(h^3). 
\label{_auto21}
\end{equation}
$$

<p>The difference between the previous one-step methods 
is that we now need an intermediate step in our evaluation,
namely \( t_i+h/2 = t_{(i+1/2)} \) where we evaluate the derivative \( f \). 
This involves more operations, but the gain is a better stability
in the solution.
</p>

<p>The fourth-order Runge-Kutta, RK4, has the following algorithm</p>
$$
k_1=hf(t_i,y_i) \hspace{0.5cm}   k_2=hf(t_i+h/2,y_i+k_1/2)
$$

$$
k_3=hf(t_i+h/2,y_i+k_2/2)\hspace{0.5cm}   k_4=hf(t_i+h,y_i+k_3)
$$

<p>with the final result</p>
$$
y_{i+1}=y_i +\frac{1}{6}\left( k_1 +2k_2+2k_3+k_4\right).
$$

<p>Thus, the algorithm consists in first calculating \( k_1 \) 
with \( t_i \), \( y_1 \) and \( f \) as inputs. Thereafter, we increase the step
size by \( h/2 \) and calculate \( k_2 \), then \( k_3 \) and finally \( k_4 \). The global error goes as \( O(h^4) \).
</p>

<p>However, at this stage, if we keep adding different methods in our
main program, the code will quickly become messy and ugly. Before we
proceed thus, we will now introduce functions that enbody the various
methods for solving differential equations. This means that we can
separate out these methods in own functions and files (and later as classes and more
generic functions) and simply call them when needed. Similarly, we
could easily encapsulate various forces or other quantities of
interest in terms of functions. To see this, let us bring up the code
we developed above for the simple sliding block, but now only with the simple forward Euler method. We introduce
two functions, one for the simple Euler method and one for the
force.
</p>

<p>Note that here the forward Euler method does not know the specific force function to be called.
It receives just an input the name. We can easily change the force by adding another function.
</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ForwardEuler</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
        v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*Force(v[i],x[i],t[i])
        x[i+<span style="color: #B452CD">1</span>] = x[i] + DeltaT*v[i]
        t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">SpringForce</span>(v,x,t):
<span style="color: #228B22">#   note here that we have divided by mass and we return the acceleration</span>
    <span style="color: #8B008B; font-weight: bold">return</span>  -<span style="color: #B452CD">2</span>*gamma*v-x+Ftilde*cos(t*Omegatilde)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>It is easy to add a new method like the Euler-Cromer</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ForwardEulerCromer</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
        a = Force(v[i],x[i],t[i])
        v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*a
        x[i+<span style="color: #B452CD">1</span>] = x[i] + DeltaT*v[i+<span style="color: #B452CD">1</span>]
        t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>and the Velocity Verlet method (be careful with time-dependence here, it is not an ideal method for non-conservative forces))</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">VelocityVerlet</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
        a = Force(v[i],x[i],t[i])
        x[i+<span style="color: #B452CD">1</span>] = x[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*a*DeltaT*DeltaT
        anew = Force(v[i],x[i+<span style="color: #B452CD">1</span>],t[i+<span style="color: #B452CD">1</span>])
        v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
        t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Finally, we can now add the Runge-Kutta2 method via a new function</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">RK2</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
<span style="color: #228B22"># Setting up k1</span>
        k1x = DeltaT*v[i]
        k1v = DeltaT*Force(v[i],x[i],t[i])
<span style="color: #228B22"># Setting up k2</span>
        vv = v[i]+k1v*<span style="color: #B452CD">0.5</span>
        xx = x[i]+k1x*<span style="color: #B452CD">0.5</span>
        k2x = DeltaT*vv
        k2v = DeltaT*Force(vv,xx,t[i]+DeltaT*<span style="color: #B452CD">0.5</span>)
<span style="color: #228B22"># Final result</span>
        x[i+<span style="color: #B452CD">1</span>] = x[i]+k2x
        v[i+<span style="color: #B452CD">1</span>] = v[i]+k2v
	t[i+<span style="color: #B452CD">1</span>] = t[i]+DeltaT
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Finally, we can now add the Runge-Kutta2 method via a new function</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">RK4</span>(v,x,t,n,Force):
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
<span style="color: #228B22"># Setting up k1</span>
        k1x = DeltaT*v[i]
        k1v = DeltaT*Force(v[i],x[i],t[i])
<span style="color: #228B22"># Setting up k2</span>
        vv = v[i]+k1v*<span style="color: #B452CD">0.5</span>
        xx = x[i]+k1x*<span style="color: #B452CD">0.5</span>
        k2x = DeltaT*vv
        k2v = DeltaT*Force(vv,xx,t[i]+DeltaT*<span style="color: #B452CD">0.5</span>)
<span style="color: #228B22"># Setting up k3</span>
        vv = v[i]+k2v*<span style="color: #B452CD">0.5</span>
        xx = x[i]+k2x*<span style="color: #B452CD">0.5</span>
        k3x = DeltaT*vv
        k3v = DeltaT*Force(vv,xx,t[i]+DeltaT*<span style="color: #B452CD">0.5</span>)
<span style="color: #228B22"># Setting up k4</span>
        vv = v[i]+k3v
        xx = x[i]+k3x
        k4x = DeltaT*vv
        k4v = DeltaT*Force(vv,xx,t[i]+DeltaT)
<span style="color: #228B22"># Final result</span>
        x[i+<span style="color: #B452CD">1</span>] = x[i]+(k1x+<span style="color: #B452CD">2</span>*k2x+<span style="color: #B452CD">2</span>*k3x+k4x)/<span style="color: #B452CD">6.</span>
        v[i+<span style="color: #B452CD">1</span>] = v[i]+(k1v+<span style="color: #B452CD">2</span>*k2v+<span style="color: #B452CD">2</span>*k3v+k4v)/<span style="color: #B452CD">6.</span>
        t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The Runge-Kutta family of methods are particularly useful when we have a time-dependent acceleration.
If we have forces which depend only the spatial degrees of freedom (no velocity and/or time-dependence), then energy conserving methods like the Velocity Verlet or the Euler-Cromer method are preferred. As soon as we introduce an explicit time-dependence and/or add dissipitave forces like friction or air resistance, then methods like the family of Runge-Kutta methods are well suited for this. 
The code below uses the Runge-Kutta4 methods. 
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;">DeltaT = <span style="color: #B452CD">0.001</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">20</span> <span style="color: #228B22"># in dimensionless time</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v, and x</span>
t = np.zeros(n)
v = np.zeros(n)
x = np.zeros(n)
<span style="color: #228B22"># Initial conditions (can change to more than one dim)</span>
x0 =  <span style="color: #B452CD">1.0</span> 
v0 = <span style="color: #B452CD">0.0</span>
x[<span style="color: #B452CD">0</span>] = x0
v[<span style="color: #B452CD">0</span>] = v0
gamma = <span style="color: #B452CD">0.2</span>
Omegatilde = <span style="color: #B452CD">0.5</span>
Ftilde = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Start integrating using Euler&#39;s method</span>
<span style="color: #228B22"># Note that we define the force function as a SpringForce</span>
RK4(v,x,t,n,SpringForce)

<span style="color: #228B22"># Plot position as function of time    </span>
fig, ax = plt.subplots()
ax.set_ylabel(<span style="color: #CD5555">&#39;x[m]&#39;</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;t[s]&#39;</span>)
ax.plot(t, x)
fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;ForcedBlockRK4&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- ------------------- end of main content --------------- -->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2022, "Morten Hjorth-Jensen":"http://mhjgit.github.io/info/doc/web/". Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>


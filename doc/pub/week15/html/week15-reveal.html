<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="PHY321: Variational calculus">

<title>PHY321: Variational calculus</title>







<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .reveal .alert-text-small   { font-size: 80%;  }
    .reveal .alert-text-large   { font-size: 130%; }
    .reveal .alert-text-normal  { font-size: 90%;  }
    .reveal .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
             -webkit-border-radius: 14px; -moz-border-radius: 14px;
             border-radius:14px;
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .reveal .alert-block {padding-top:14px; padding-bottom:14px}
     .reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
     /*.reveal .alert li {margin-top: 1em}*/
     .reveal .alert-block p+p {margin-top:5px}
     /*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
     .reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
     .reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
     .reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body>
<div class="reveal">

<!-- Any section element inside the <div class="slides"> container
     is displayed as a slide -->

<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    



<section>
<!-- ------------------- main content ---------------------- -->



<center><h1 style="text-align: center;">PHY321: Variational calculus</h1></center>  <!-- document title -->

<p>
<!-- author(s): <a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a> -->

<center>
<b><a href="http://mhjgit.github.io/info/doc/web/" target="_blank">Morten Hjorth-Jensen</a></b> [1, 2]
</center>

<p>&nbsp;<br>
<!-- institution(s) -->

<center>[1] <b>Department of Physics and Astronomy and Facility for Rare Ion Beams (FRIB), Michigan State University, USA</b></center>
<center>[2] <b>Department of Physics, University of Oslo, Norway</b></center>
<br>
<p>&nbsp;<br>
<center><h4>Apr 17, 2021</h4></center> <!-- date -->
<br>
<p>

<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2021, "Morten Hjorth-Jensen":"http://mhjgit.github.io/info/doc/web/". Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>


<section>
<h2 id="aims-and-overarching-motivation">Aims and Overarching Motivation </h2>

<h3 id="monday">Monday </h3>

<ul>
<p><li> Euler-Lagrange equations and the Lagrangian with examples</li>
<p><li> Principle of Least Action, watch <a href="https://www.feynmanlectures.caltech.edu/II_19.html" target="_blank">Feynman Lecture</a>.</li>
<p><li> Discussions of second midterm, see codes right after this slide.</li>
</ul>
<p>

<a href="https://mediaspace.msu.edu/media/t/1_glmwe3s1" target="_blank">See video from Monday April 12, with discussions of part 1 of the midterm</a>

<p>
<b>Reading suggestion</b>: Taylor sections 6.3-6.4

<h3 id="wednesday">Wednesday </h3>

<ul>
<p><li> Lagrangian formalism, constrained and unconstrained motion</li>
<p><li> Discussions of second midterm, see codes right after this slide.</li>
</ul>
<p>

<a href="https://mediaspace.msu.edu/media/t/1_foeveqvo" target="_blank">See video from Wednesday April 14, with discussion of part 2 of the midterm</a>
<b>Reading suggestion</b>: Taylor sections 7.1-7.4

<h3 id="friday">Friday </h3>

<ul>
<p><li> Variational Calculus with examples</li>
<p><li> Discussions of second midterm, see codes right after this slide.</li>
</ul>
<p>

<a href="https://mediaspace.msu.edu/media/t/1_9tdk8c94" target="_blank">See video from Wednesday April 14, with discussion of part 2 of the midterm</a>

<p>
<b>Reading suggestion</b>: Taylor sections 7.5-7.8

<p>
<b>Additional HW 10 available</b> at <a href="https://mhjensen.github.io/Physics321/doc/Homeworks/hw10/html/hw10.html" target="_blank"><tt>https://mhjensen.github.io/Physics321/doc/Homeworks/hw10/html/hw10.html</tt></a>
</section>


<section>
<h2 id="second-midterm-angular-momentum-and-kepler-s-laws">Second midterm, Angular Momentum and Kepler's Laws </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span>%matplotlib inline

<span style="color: #228B22"># let&#39;s start by importing useful packages we are familiar with</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">seaborn</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sns</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span> 

<span style="color: #228B22">#Velocity-Verlet Method</span>
newDeltaT = <span style="color: #B452CD">0.001</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">10</span> <span style="color: #228B22"># in years</span>
n = ceil(tfinal/newDeltaT)
<span style="color: #228B22"># set up arrays for time t, velocity v, and position r</span>
t = np.zeros(n)
v = np.zeros((n,<span style="color: #B452CD">2</span>))
r = np.zeros((n,<span style="color: #B452CD">2</span>))
<span style="color: #228B22">#newa = np.zeros((n,2))</span>
<span style="color: #228B22"># Initial conditions as compact 2-dimensional arrays</span>
r0 = np.array([<span style="color: #B452CD">1.0</span>,<span style="color: #B452CD">0.0</span>])
v0 = np.array([<span style="color: #B452CD">0.0</span>,<span style="color: #B452CD">2</span>*pi])
<span style="color: #228B22">#newa0 = np.array(-Fourpi2*newr0)</span>
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
<span style="color: #228B22">#newa[0] = newa0</span>
Fourpi2 = <span style="color: #B452CD">4</span>*pi*pi
<span style="color: #228B22"># Start integrating using Euler&#39;s method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up the accelerationn</span>
    <span style="color: #228B22"># Here you could have defined your own function for this</span>
    rabs = sqrt(<span style="color: #658b00">sum</span>(r[i]*r[i]))
    a = -Fourpi2*r[i]/(rabs**<span style="color: #B452CD">3</span>)
    <span style="color: #228B22"># update velocity, time and position using Euler&#39;s forward method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + newDeltaT*v[i] + ((newDeltaT**<span style="color: #B452CD">2</span>)/<span style="color: #B452CD">2</span>)*(a)
    rabs = sqrt(<span style="color: #658b00">sum</span>(r[i+<span style="color: #B452CD">1</span>]*r[i+<span style="color: #B452CD">1</span>]))
    agh_a = -<span style="color: #B452CD">4</span>*(pi**<span style="color: #B452CD">2</span>)*r[i+<span style="color: #B452CD">1</span>]/(rabs**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + newDeltaT*(<span style="color: #B452CD">0.5</span>)*(a + agh_a)
    t[i+<span style="color: #B452CD">1</span>] = t[i] + newDeltaT
sns.set()
plt.plot(r[:,<span style="color: #B452CD">0</span>], r[:,<span style="color: #B452CD">1</span>])
</pre></div>
</section>


<section>
<h2 id="the-angular-momentum-part">The Angular momentum Part </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">AreaCalc</span>(rad1,rad2):
    rad1n = np.linalg.norm(rad1)
    rad2n = np.linalg.norm(rad2)
    theta1 = math.atan(<span style="color: #658b00">abs</span>(rad1[<span style="color: #B452CD">1</span>]/rad1[<span style="color: #B452CD">0</span>]))
    theta2 = math.atan(<span style="color: #658b00">abs</span>(rad2[<span style="color: #B452CD">1</span>]/rad2[<span style="color: #B452CD">0</span>]))
    radn = <span style="color: #B452CD">0.5</span>*(rad1n+rad2n)
    delta_theta = np.abs(theta1 - theta2)
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*delta_theta*radn**<span style="color: #B452CD">2</span>
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">AngMomentum</span>(rad,vel):
    radn = np.linalg.norm(rad)
    veln = np.linalg.norm(vel)
    rad = rad/radn
    vel = vel/veln
    dotprod = rad[<span style="color: #B452CD">0</span>]*vel[<span style="color: #B452CD">0</span>]+rad[<span style="color: #B452CD">1</span>]*vel[<span style="color: #B452CD">1</span>]
    theta = math.acos(dotprod)
    <span style="color: #8B008B; font-weight: bold">return</span> radn*veln*np.sin(theta)
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span>AreaVal = np.zeros(<span style="color: #658b00">len</span>(t))
AreaVal[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>
AngMo = np.zeros(<span style="color: #658b00">len</span>(t))  
AngMo[<span style="color: #B452CD">0</span>] = AngMomentum(r[<span style="color: #B452CD">0</span>,:],v[<span style="color: #B452CD">0</span>,:])
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,<span style="color: #658b00">len</span>(t)-<span style="color: #B452CD">1</span>):
    AreaVal[i+<span style="color: #B452CD">1</span>] = AreaVal[i] + AreaCalc(r[i,:],r[i+<span style="color: #B452CD">1</span>,:])
    AngMo[i+<span style="color: #B452CD">1</span>] = AngMomentum(r[i+<span style="color: #B452CD">1</span>,:],v[i+<span style="color: #B452CD">1</span>,:])

fig, ax = plt.subplots(<span style="color: #B452CD">2</span>,<span style="color: #B452CD">1</span>,figsize=(<span style="color: #B452CD">12</span>,<span style="color: #B452CD">6</span>))
ax[<span style="color: #B452CD">0</span>].plot(t,AreaVal,label=<span style="color: #CD5555">&#39;Area&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_title(<span style="color: #CD5555">&#39;Sweeped Area vs time&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;t [yr]&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;Area Sweeped in AU^2&#39;</span>)

ax[<span style="color: #B452CD">1</span>].plot(t,AngMo,label=<span style="color: #CD5555">&#39;Angular Momentum&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_title(<span style="color: #CD5555">&#39;Angular Momentum vs time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;t [yr]&#39;</span>)
plt.tight_layout()
</pre></div>
</section>


<section>
<h2 id="building-a-code-for-the-solar-system-gravitational-force-and-constants">Building a code for the solar system, gravitational force and constants </h2>

<p>
We start with a simpler case first, the Earth-Sun system  in two dimensions only.  The gravitational force \( F_G \) is

<p>&nbsp;<br>
$$
      F=\frac{GM_{\odot}M_E}{r^2},
  $$
<p>&nbsp;<br>

where \( G \) is the gravitational constant, 
<p>&nbsp;<br>
$$
M_E=6\times 10^{24}\mathrm{Kg},
$$
<p>&nbsp;<br>

the mass of Earth, 
<p>&nbsp;<br>
$$
M_{\odot}=2\times 10^{30}\mathrm{Kg}, 
$$
<p>&nbsp;<br>

the mass of the Sun and 
<p>&nbsp;<br>
$$
r=1.5\times 10^{11}\mathrm{m}, 
$$
<p>&nbsp;<br>

is the distance between Earth and the Sun. The latter defines what we call an astronomical unit <b>AU</b>.

<p>
From Newton's second law we have then for the \( x \) direction

<p>&nbsp;<br>
$$
   \frac{d^2x}{dt^2}=\frac{F_{x}}{M_E},
  $$
<p>&nbsp;<br>

<p>
and

<p>&nbsp;<br>
$$
   \frac{d^2y}{dt^2}=\frac{F_{y}}{M_E},
  $$
<p>&nbsp;<br>

for the \( y \) direction.
</section>


<section>
<h2 id="building-a-code-for-the-solar-system-force-equations">Building a code for the solar system, force equations </h2>

<p>
Introducing \( x=r\cos{(\theta)} \), \( y=r\sin{(\theta)} \) and
<p>&nbsp;<br>
$$
r = \sqrt{x^2+y^2},
$$
<p>&nbsp;<br>

<p>
we can rewrite

<p>&nbsp;<br>
$$
   F_{x}=-\frac{GM_{\odot}M_E}{r^2}\cos{(\theta)}=-\frac{GM_{\odot}M_E}{r^3}x,
  $$
<p>&nbsp;<br>

<p>
and

<p>&nbsp;<br>
$$
     F_{y}=-\frac{GM_{\odot}M_E}{r^2}\sin{(\theta)}=-\frac{GM_{\odot}M_E}{r^3}y,
  $$
<p>&nbsp;<br>

<p>
for the \( y \) direction.
</section>


<section>
<h2 id="building-a-code-for-the-solar-system-coupled-equations">Building a code for the solar system, coupled equations </h2>

<p>
We can rewrite these two equations
<p>&nbsp;<br>
$$
   F_{x}=-\frac{GM_{\odot}M_E}{r^2}\cos{(\theta)}=-\frac{GM_{\odot}M_E}{r^3}x,
  $$
<p>&nbsp;<br>

<p>
and

<p>&nbsp;<br>
$$
     F_{y}=-\frac{GM_{\odot}M_E}{r^2}\sin{(\theta)}=-\frac{GM_{\odot}M_E}{r^3}y,
  $$
<p>&nbsp;<br>

<p>
as four first-order coupled differential equations

<p>&nbsp;<br>
$$
   \frac{dv_x}{dt}=-\frac{GM_{\odot}}{r^3}x,
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   \frac{dx}{dt}=v_x,
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   \frac{dv_y}{dt}=-\frac{GM_{\odot}}{r^3}y,
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   \frac{dy}{dt}=v_y.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="building-a-code-for-the-solar-system-final-coupled-equations">Building a code for the solar system, final coupled equations </h2>

<p>
The four coupled differential equations

<p>&nbsp;<br>
$$
   \frac{dv_x}{dt}=-\frac{GM_{\odot}}{r^3}x,
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   \frac{dx}{dt}=v_x,
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   \frac{dv_y}{dt}=-\frac{GM_{\odot}}{r^3}y,
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   \frac{dy}{dt}=v_y,
$$
<p>&nbsp;<br>

<p>
can be turned into dimensionless equations (as we did in project 2) or we can introduce astronomical units with \( 1 \) AU = \( 1.5\times 10^{11} \).

<p>
Using the equations from circular motion (with \( r =1\mathrm{AU} \))

<p>&nbsp;<br>
$$
\frac{M_E v^2}{r} = F = \frac{GM_{\odot}M_E}{r^2},
$$
<p>&nbsp;<br>

<p>
we have

<p>&nbsp;<br>
$$
GM_{\odot}=v^2r,
$$
<p>&nbsp;<br>

<p>
and using that the velocity of Earth (assuming circular motion) is
\( v = 2\pi r/\mathrm{yr}=2\pi\mathrm{AU}/\mathrm{yr} \), we have

<p>&nbsp;<br>
$$
GM_{\odot}= v^2r = 4\pi^2 \frac{(\mathrm{AU})^3}{\mathrm{yr}^2}.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="building-a-code-for-the-solar-system-discretized-equations">Building a code for the solar system, discretized equations </h2>

<p>
The four coupled differential equations can then be discretized using the Euler-Cromer method as (with step length \( h \))
<p>&nbsp;<br>
$$
   v_{x,i+1}=v_{x,i}-h\frac{4\pi^2}{r_i^3}x_i,
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   x_{i+1}=x_i+hv_{x,i+1},
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   v_{y,i+1}=v_{y,i}-h\frac{4\pi^2}{r_i^3}y_i,
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
   y_{i+1}=y_i+hv_{y,i+1},
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="building-a-code-for-the-solar-system-adding-jupiter">Building a code for the solar system, adding Jupiter </h2>

<p>
It is rather straightforward to add a new planet, say Jupiter.
Jupiter has mass
<p>&nbsp;<br>
$$
M_J=1.9\times 10^{27}\mathrm{kg},
$$
<p>&nbsp;<br>

and distance to the Sun of \( 5.2 \) AU. 
The additional gravitational force the Earth feels from Jupiter in the \( x \)-direction is
<p>&nbsp;<br>
$$
   F_{x}^{EJ}=-\frac{GM_JM_E}{r_{EJ}^3}(x_E-x_J),
  $$
<p>&nbsp;<br>

where \( E \) stands for Earth, \( J \) for Jupiter, \( r_{EJ} \) is distance between Earth and Jupiter
<p>&nbsp;<br>
$$
r_{EJ} = \sqrt{(x_E-x_J)^2+(y_E-y_J)^2},
$$
<p>&nbsp;<br>

and \( x_E \) and \( y_E \) are the \( x \) and \( y \) coordinates of Earth, respectively, and 
\( x_J \) and \( y_J \) are the \( x \) and \( y \) coordinates of Jupiter, respectively.
The \( x \)-component of the velocity of Earth changes thus to
<p>&nbsp;<br>
$$
   \frac{dv_x^E}{dt}=-\frac{GM_{\odot}}{r^3}x_E-\frac{GM_J}{r_{EJ}^3}(x_E-x_J).
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="building-a-code-for-the-solar-system-adding-jupiter">Building a code for the solar system, adding Jupiter </h2>

<p>
We can rewrite 
<p>&nbsp;<br>
$$
   \frac{dv_x^E}{dt}=-\frac{GM_{\odot}}{r^3}x_E-\frac{GM_J}{r_{EJ}^3}(x_E-x_J).
$$
<p>&nbsp;<br>

<p>
to

<p>&nbsp;<br>
$$
   \frac{dv_x^E}{dt}=-\frac{4\pi^2}{r^3}x_E-\frac{4\pi^2M_J/M_{\odot}}{r_{EJ}^3}(x_E-x_J),
$$
<p>&nbsp;<br>

<p>
where we used

<p>&nbsp;<br>
$$
GM_J = GM_{\odot}\left(\frac{M_J}{M_{\odot}}\right)=4\pi^2 \frac{M_J}{M_{\odot}}.
$$
<p>&nbsp;<br>

<p>
Similarly, for the velocity in \( y \)-direction we have

<p>&nbsp;<br>
$$
   \frac{dv_y^E}{dt}=-\frac{4\pi^2}{r^3}y_E-\frac{4\pi^2M_J/M_{\odot}}{r_{EJ}^3}(y_E-y_J).
$$
<p>&nbsp;<br>

<p>
Similar expressions apply for Jupiter. The equations for \( x \) and \( y \) 
derivatives are unchanged. This equations are similar for all other planets and as we will see later, it will be convenient to object orient this part when we program the full solar system.
</section>


<section>
<h2 id="how-can-i-get-the-initial-velocities-and-positions-of-the-planets">How can I get the initial velocities and positions of the planets </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<a href="http://www.nasa.gov/index.html" target="_blank">NASA</a> has an excellent site at <a href="http://ssd.jpl.nasa.gov/horizons.cgi#top" target="_blank"><tt>http://ssd.jpl.nasa.gov/horizons.cgi#top</tt></a>.
From there you can extract initial conditions in order to start your differential equation solver.
At the above website you need to change from <b>OBSERVER</b> to <b>VECTOR</b> and then write in the planet you are interested in.
The generated data contain the \( x \), \( y \) and \( z \) values as well as their corresponding velocities. The velocities are in units of AU per day.
Alternatively they can be obtained in terms of km and km/s.

<p>
For the first simple system involving the Earth and the Sun, you could just initialize the position with say \( x=1 \) AU
and \( y=0 \) AU.
</div>
</section>


<section>
<h2 id="code-example">Code Example </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span>
%matplotlib inline

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solarsystem_j_scaled</span>(f = <span style="color: #B452CD">1</span>, tf = <span style="color: #B452CD">100</span>, dt = .<span style="color: #B452CD">01</span>):
    m_j = <span style="color: #B452CD">1.9</span> * <span style="color: #B452CD">10</span>**<span style="color: #B452CD">27</span> * f
    m_e = <span style="color: #B452CD">6</span> * <span style="color: #B452CD">10</span> ** <span style="color: #B452CD">24</span>
    m_s = <span style="color: #B452CD">2</span> * <span style="color: #B452CD">10</span> ** <span style="color: #B452CD">30</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">get_accel</span>(m1,m2,r1,r2):
        <span style="color: #CD5555">&#39;&#39;&#39;</span>
<span style="color: #CD5555">        Given a masses and locations m1, m2, r1, r2</span>
<span style="color: #CD5555">        Returns the force between the two masses, </span>
<span style="color: #CD5555">        f = [fx, fy]</span>
<span style="color: #CD5555">        &#39;&#39;&#39;</span>
        dist = r1-r2
        dist_sun = np.sqrt((r1[<span style="color: #B452CD">0</span>])**<span style="color: #B452CD">2</span> + (r1[<span style="color: #B452CD">1</span>])**<span style="color: #B452CD">2</span>)
        distance = np.sqrt((r1[<span style="color: #B452CD">0</span>]-r2[<span style="color: #B452CD">0</span>])**<span style="color: #B452CD">2</span> + (r1[<span style="color: #B452CD">1</span>]-r2[<span style="color: #B452CD">1</span>])**<span style="color: #B452CD">2</span>)
        a = -<span style="color: #B452CD">4</span>*math.pi**<span style="color: #B452CD">2</span>*r1/dist_sun**<span style="color: #B452CD">3</span>-<span style="color: #B452CD">4</span>*math.pi**<span style="color: #B452CD">2</span>*dist*(m2/m_s)/distance**<span style="color: #B452CD">3</span>
        <span style="color: #8B008B; font-weight: bold">return</span> a
    
    r_s = np.array([<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>])
    n = math.ceil(tf/dt)
    <span style="color: #658b00">print</span>(<span style="color: #CD5555">&#39;Integration points: &#39;</span>, n)
    
    <span style="color: #228B22"># set up arrays for time t, velocity v, and position r</span>
    t = np.zeros(n)
    v_j = np.zeros((n,<span style="color: #B452CD">2</span>))
    r_j = np.zeros((n,<span style="color: #B452CD">2</span>))
    r_j[<span style="color: #B452CD">0</span>] = np.array([<span style="color: #B452CD">0</span>, <span style="color: #B452CD">5.2</span>])
    v_j[<span style="color: #B452CD">0</span>] = np.array([-<span style="color: #B452CD">2.76</span>, <span style="color: #B452CD">0</span>])
    
    v_e = np.zeros((n,<span style="color: #B452CD">2</span>))
    r_e = np.zeros((n,<span style="color: #B452CD">2</span>))
    r_e[<span style="color: #B452CD">0</span>] = np.array([<span style="color: #B452CD">1</span>, <span style="color: #B452CD">0</span>])
    v_e[<span style="color: #B452CD">0</span>] = np.array([<span style="color: #B452CD">0</span>, <span style="color: #B452CD">6.28</span>])
    
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
        accel_earth = get_accel(m_e, m_j, r_e[i], r_j[i])
        accel_jupyter = get_accel(m_j, m_e, r_j[i], r_e[i])
        
        r_e[i+<span style="color: #B452CD">1</span>] = r_e[i] + dt*v_e[i]+.<span style="color: #B452CD">5</span>*dt**<span style="color: #B452CD">2</span>*accel_earth
        r_j[i+<span style="color: #B452CD">1</span>] = r_j[i] + dt*v_j[i]+.<span style="color: #B452CD">5</span>*dt**<span style="color: #B452CD">2</span>*accel_jupyter
        
        <span style="color: #228B22"># Update forces, accel</span>
        accel_earth_2 = get_accel(m_e, m_j, r_e[i+<span style="color: #B452CD">1</span>], r_j[i+<span style="color: #B452CD">1</span>])
        accel_jupyter_2 = get_accel(m_j, m_e, r_j[i+<span style="color: #B452CD">1</span>], r_e[i+<span style="color: #B452CD">1</span>])
        
        v_e[i+<span style="color: #B452CD">1</span>] = v_e[i] + <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*dt*(accel_earth + accel_earth_2)
        v_j[i+<span style="color: #B452CD">1</span>] = v_j[i] + <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*dt*(accel_jupyter + accel_jupyter_2)
        
        t[i+<span style="color: #B452CD">1</span>] = t[i] + dt
    
    plt.plot(r_e[:, <span style="color: #B452CD">0</span>], r_e[:, <span style="color: #B452CD">1</span>], color = <span style="color: #CD5555">&#39;green&#39;</span>)
    plt.plot(r_j[:, <span style="color: #B452CD">0</span>], r_j[:, <span style="color: #B452CD">1</span>], color = <span style="color: #CD5555">&#39;blue&#39;</span>)
    plt.scatter(<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>,color = <span style="color: #CD5555">&#39;red&#39;</span>)
</pre></div>
</section>


<section>
<h2 id="running-the-code">Running the Code  </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span>solarsystem_j_scaled(f = <span style="color: #B452CD">1</span>, tf = <span style="color: #B452CD">20</span>, dt = <span style="color: #B452CD">1</span>)
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span>solarsystem_j_scaled(f = <span style="color: #B452CD">1</span>, tf = <span style="color: #B452CD">300</span>, dt = .<span style="color: #B452CD">1</span>)
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span>solarsystem_j_scaled(f = <span style="color: #B452CD">1</span>, tf = <span style="color: #B452CD">300</span>, dt = .<span style="color: #B452CD">001</span>)
</pre></div>
<p>
Changing the mass factor
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span>solarsystem_j_scaled(f = <span style="color: #B452CD">1000</span>, tf = <span style="color: #B452CD">3</span>, dt = .<span style="color: #B452CD">001</span>)
</pre></div>
</section>


<section>
<h2 id="a-summary-of-part-i">A summary of Part I </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%;"><span></span><span style="color: #228B22"># let&#39;s start by importing useful packages we are familiar with</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">seaborn</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sns</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span> 

<span style="color: #228B22">#Velocity-Verlet Method</span>
DeltaT = <span style="color: #B452CD">0.001</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">100</span> <span style="color: #228B22"># in years</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for time t, velocity v, and position r</span>
t = np.zeros(n)
v = np.zeros((n,<span style="color: #B452CD">2</span>))
r = np.zeros((n,<span style="color: #B452CD">2</span>))
<span style="color: #228B22"># Initial conditions as compact 2-dimensional arrays. Here: circular orbit conditions.</span>
r0 = np.array([<span style="color: #B452CD">1.0</span>,<span style="color: #B452CD">0.0</span>])
v0 = np.array([<span style="color: #B452CD">0.0</span>,<span style="color: #B452CD">2</span>*pi])
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
Fourpi2 = <span style="color: #B452CD">4</span>*pi*pi
<span style="color: #228B22"># Start integrating using the Velocity-Verlet method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up the accelerationn</span>
    rabs = sqrt(<span style="color: #658b00">sum</span>(r[i]*r[i]))
    a = -Fourpi2*r[i]/(rabs**<span style="color: #B452CD">3</span>)
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet  method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i] + ((DeltaT**<span style="color: #B452CD">2</span>)/<span style="color: #B452CD">2</span>)*(a)
    rabs = sqrt(<span style="color: #658b00">sum</span>(r[i+<span style="color: #B452CD">1</span>]*r[i+<span style="color: #B452CD">1</span>]))
    anew = -<span style="color: #B452CD">4</span>*(pi**<span style="color: #B452CD">2</span>)*r[i+<span style="color: #B452CD">1</span>]/(rabs**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + DeltaT*(<span style="color: #B452CD">0.5</span>)*(a + anew)
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
sns.set()
plt.plot(r[:,<span style="color: #B452CD">0</span>], r[:,<span style="color: #B452CD">1</span>])


<span style="color: #228B22"># We check that the total energy is conserved. For a circular orbit, potential and kinetic energy do not change since the radius is a constant. </span>

<span style="color: #228B22"># Note that we have set the mass of the Earth = 1</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">kinetic_energy</span>(v):
    KE = []
    step = <span style="color: #658b00">len</span>(t)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(step):
        KE.append(<span style="color: #B452CD">0</span>)
        KE[i] += <span style="color: #B452CD">0.5</span> *np.sum(v[i]*v[i])
    <span style="color: #8B008B; font-weight: bold">return</span> np.array(KE)


<span style="color: #228B22"># Note that G x Mass_sun = 4*pi*pi and the mass of the Earth = 1</span>
<span style="color: #228B22"># Note also that if you change the exponent in the force you need also to change the potential energy!</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">pot</span>():
    Pot = []
    step = <span style="color: #658b00">len</span>(t)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(step):
        Pot.append(<span style="color: #B452CD">0</span>)
        Pot[i] +=  - <span style="color: #B452CD">4</span>*pi*pi/ sqrt(np.sum(r[i]*r[i]))
    <span style="color: #8B008B; font-weight: bold">return</span> np.array(Pot)

fig, ax = plt.subplots(<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>,figsize=(<span style="color: #B452CD">12</span>,<span style="color: #B452CD">6</span>))
ax.plot(t,kinetic_energy(v)+pot(),label=<span style="color: #CD5555">&#39;Total&#39;</span>)
ax.plot(t,kinetic_energy(v),label=<span style="color: #CD5555">&#39;Kinetic&#39;</span>)
ax.plot(t,pot(),label=<span style="color: #CD5555">&#39;Potential&#39;</span>)
ax.set_title(<span style="color: #CD5555">&#39;Energy vs time&#39;</span>)
ax.set_xlabel(<span style="color: #CD5555">&#39;t [yr]&#39;</span>)
ax.legend()
ax.set_ylabel(<span style="color: #CD5555">r&#39;E&#39;</span>)


<span style="color: #228B22"># With the same initial conditions we use Kepler&#39;s second law (see Taylor section 3.4) to show that angular momentum is conserved. </span>


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">AreaCalc</span>(rad1,rad2):
    rad1n = np.linalg.norm(rad1)
    rad2n = np.linalg.norm(rad2)
    theta1 = math.atan(<span style="color: #658b00">abs</span>(rad1[<span style="color: #B452CD">1</span>]/rad1[<span style="color: #B452CD">0</span>]))
    theta2 = math.atan(<span style="color: #658b00">abs</span>(rad2[<span style="color: #B452CD">1</span>]/rad2[<span style="color: #B452CD">0</span>]))
    radn = <span style="color: #B452CD">0.5</span>*(rad1n+rad2n)
    delta_theta = np.abs(theta1 - theta2)
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*delta_theta*radn**<span style="color: #B452CD">2</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">AngMomentum</span>(rad,vel):
    radn = np.linalg.norm(rad)
    veln = np.linalg.norm(vel)
    rad = rad/radn
    vel = vel/veln
    dotprod = rad[<span style="color: #B452CD">0</span>]*vel[<span style="color: #B452CD">0</span>]+rad[<span style="color: #B452CD">1</span>]*vel[<span style="color: #B452CD">1</span>]
    theta = math.acos(dotprod)
    <span style="color: #8B008B; font-weight: bold">return</span> radn*veln*np.sin(theta)


AreaVal = np.zeros(<span style="color: #658b00">len</span>(t))
AreaVal[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>
AngMo = np.zeros(<span style="color: #658b00">len</span>(t))  
AngMo[<span style="color: #B452CD">0</span>] = AngMomentum(r[<span style="color: #B452CD">0</span>,:],v[<span style="color: #B452CD">0</span>,:])

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,<span style="color: #658b00">len</span>(t)-<span style="color: #B452CD">1</span>):
    AreaVal[i+<span style="color: #B452CD">1</span>] = AreaVal[i] + AreaCalc(r[i,:],r[i+<span style="color: #B452CD">1</span>,:])
    AngMo[i+<span style="color: #B452CD">1</span>] = AngMomentum(r[i+<span style="color: #B452CD">1</span>,:],v[i+<span style="color: #B452CD">1</span>,:])

fig, ax = plt.subplots(<span style="color: #B452CD">2</span>,<span style="color: #B452CD">1</span>,figsize=(<span style="color: #B452CD">12</span>,<span style="color: #B452CD">6</span>))
ax[<span style="color: #B452CD">0</span>].plot(t,AreaVal,label=<span style="color: #CD5555">&#39;Area&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_title(<span style="color: #CD5555">&#39;Sweeped Area vs time&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;t [yr]&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;Area Sweeped in AU^2&#39;</span>)

ax[<span style="color: #B452CD">1</span>].plot(t,AngMo,label=<span style="color: #CD5555">&#39;Angular Momentum&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_title(<span style="color: #CD5555">&#39;Angular Momentum vs time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;t [yr]&#39;</span>)
plt.tight_layout()
</pre></div>
</section>


<section>
<h2 id="variational-calculus">Variational Calculus </h2>

<p>
The calculus of variations involves 
problems where the quantity to be minimized or maximized is an integral.

<p>
The usual minimization problem one faces involves taking a function
\( {\cal L}(x) \), then finding the single value \( x \) for which \( {\cal L} \)
is either a maximum or minimum. In multivariate calculus one also
learns to solve problems where you minimize for multiple variables,
\( {\cal L}(x_1,x_2,\cdots x_n) \), and finding the points \( (x_1\cdots
y_n) \) in an \( n \)-dimensional space that maximize or minimize the
function. Here, we consider what seems to be a much more ambitious
problem. Imagine you have a function \( {\cal L}(x(t),\dot{x}(t),t) \),
and you wish to find the extrema for an infinite number of values of
\( x \), i.e. \( x \) at each point \( t \). The function \( {\cal L} \) will not only
depend on \( x \) at each point \( t \), but also on the slope at each point,
plus an additional dependence on \( t \). Note we are NOT finding an
optimum value of \( t \), we are finding the set of optimum values of \( x \)
at each point \( t \), or equivalently, finding the function \( x(t) \).
</section>


<section>
<h2 id="variational-calculus-introducing-the-action">Variational Calculus, introducing the action </h2>

<p>
One treats the function \( x(t) \) as being unknown while minimizing the action

<p>&nbsp;<br>
$$
S=\int_{t_1}^{t_2}dt茔犰听舂茕雉舂舂い拣睛钼箴患怛拣澡躞麇狎黹铋黹轭塄堠鏖翳蝈箴邈麸犷轭骈铋翦铛礅弪镦鲠祯弩镦塄暨椹堠狒痫轭趔塄暨堠馏犷徜溟糸镱犰泸轸弪獒麇鏖祆狍篚礤翳狒塄暨暴堠犷塄暨博堠狎骈邃犷翳狒翳狒麇鏖祆镱禊泔铙殇弪鲠蜷狒轱铙镦塄堠忮赭邋翳怙躅溽蜷弩澡溴疱钿孱沐镱翳溴蜷鲠糸鲥塄茕雉戒漪堠轶泸蹉獒忮汜躞雉桢蝼轶翳箫祯糸镱黠蹯轭鲲祧箝眇禊骈钿轭翳镱鲠祯镦塄堠翳狒黹铋黹邃塄茔犰听堠犷塄舂堠黠蹯羼踽泔铙翎铘殒翳弪麇蝈铒屮痨殂轸塄堠溴疱钿孱沐契螋桢蝽矧瀣塄堠黠蹯漕铄邃麸忮泔铘轭躏躞狒翳怙躅溽蝙集箦泗轱罹俭邈糸镱艰殇舰鲠蜷狒轱钺飙汜煦蹯躞珏铄蜥飙徙糸镱⒕轴蜷狒轱钺冕煦蹯躞珏铄蜥零糸镱集璨拣深翳珏铄蜥汜箦麇栳鲥犷轭翦珧犰镦翳豉疱拣睛钼箴患怛い盂褫荛铘啕暨饼摞暨昌茔犰听瘿舂茕雉颀舂舂漪い拣睛钼箴患怛拣麒弪塄堠轶翳聃犷糸豉麒殂轶箫蹒梏黹铋黹邃矧磲轫辁邃澡痱镡戾轶翳狒犰翳秕玷塄茔犰听堠轶骢钽糸镱镦翳珏铄蜥鲠蜷徕戾塄瘿舂茕雉颀舂堠铒翦秕汨犷珏镦鲠蜷徕戾螬翳屮徙溴疱钿孱沐镦塄堠镱塄堠轶铒腩秣町澡轶礤犷徵衢翳狒弼孱翳秕玷翳轭翦珧犰栳骈邃扉黹趔塄暨堠犷塄暨堠翳疳翳镦轭翦珧狒轱轶铒腩秣町深秕汜箦翳躅腩秣聃犷糸糸弩狎翳痫箝糸镱犷珏铄蜥鲥祜汩糸弩镦玳鲥铛礅弪镦镡赍泗犷麇鏖箬麸汨镲箦犷轭翦珧狒轱疳翳麒殂磲脲翳骢钽糸镱犰塄盂褫堠篝狒轱钺蝙澡轶礤犷翳狒麇麽铘麸骈钿黹铋磲矧磲轫矧筢滗戾痫轭趔深痂箝泱麇箦狎汨铒蝽犰禊骘黹铋磲硝翎箅轶翳弪彐矧麸骈钿翳黹铋眭镦塄盂褫堠箫翳狒轸鲠蜷狒轱塄茕屐翎堠轶弪篚怅邈麸箴邈殒殂泔铙趄衢铘螽澡泔铙趄衢铘汜忮趄遽翦鲩翳翦汨铋聃镦提珧犷玳犷眭祠轲扉弪狍麇鏖祆箦忮祜鳟集箦泗轱罹俭邈糸镱艰殇舰鲠蜷狒轱钺飙汜煦蹯躞镳糸磲飙疳翳⒕轴蜷狒轱钺冕煦蹯躞橡糸磲嗅翳集璨拣族狍篚礤翳屮轶翦钽镦犷镳糸眭疳翳翳狒轶疳翳骘麒殂塄盂褫堠轶篝狒轱钺蝙澡弪狎轭骈铋翦禊磲铢篚汨疳翳螽澡溟骀弪孱沐忮赭邋赭疳翳塄茕屐翎堠轶汜祆邃翳鲠蜷狒轱镦塄堠拣族汜祆翳鲠蜷狒轱塄苠翎舂堠犷轸轶筱犰邃怡驷泗矧塄茚祓栳堠澡骢钽糸镱塄苠翎舂堠轶狎忾趄狎屮沐痿骘拣睛钼箴患怛い苠翎暨暴杰弭屺暨博桨い拣睛钼箴患怛拣犷麇狍篚礤翳狒麇汜盹溴翳汨犷珏轭塄堠狍拣睛钼箴患怛い瘿衄茚祓栳瘿舂茚祓栳苠翎舂い拣睛钼箴患怛拣犷拣睛钼箴患怛い茕屐翎瘿衄茚祓栳瘿衄癌杰犰痂彳弭屺舂い拣睛钼箴患怛集箦泗轱罹俭邈糸镱艰殇舰鲠蜷狒轱钺飙汜煦蹯躞泔钿轸轱瞽骘颦犷屮趄屙瀛鲠祯澧局狎獒糸镱犰冕煦蹯躞蔑钿轸轱骘犷砒趄屙轴祯集璨拣族汨镲箦塄瘿衄茚祓栳桨堠狍翳躅腼铟疳翳翳狒鏖祆黹铋黹塄堠澡鲠祯塄瘿衄茚祓栳茴癌堠溴筱蜷忮铄殓桠秕蜷铉疳翳拣族栳鲥拣睛钼箴患怛い盂瘿茚祓栳┹荛铘啕暨饼摞暨昌茔犰听瘿衄茚祓栳┈茕雉颀衄茚祓栳┈舂漪い拣睛钼箴患怛拣澡泔钿轸轱骘犷屮趄屙镦拣睛钼箴患怛い盂瘿茚祓栳┹荛铘啕暨饼摞暨昌茔犰听瘿衄茚祓栳┈茕雉颀衄茚祓栳┈舂漪い拣睛钼箴患怛拣轶拣睛钼箴患怛い莒彐糅苕蜥沱莛狎糸犰盂瘿茚祓栳┹莛狎糸犰酏茯殓梏葸茚祓栳桨桨い拣睛钼箴患怛集箦泗轱罹俭邈糸镱艰殇舰鲠蜷狒轱钺飙汜煦蹯躞犰痂岘溴疱钿孱沐⒕轴蜷狒轱钺冕煦蹯躞塄茚祓栳堠腻疱钿孱沐集璨拣澡塄茚祓栳堠溴疱钿孱沐轶泔铘衢铄轭塄瘿衄茚祓栳堠犷塄茕雉颀衄茚祓栳堠礤犷轭翳狒拣睛钼箴患怛い莒彐糅苕蜥沱莛狎糸犰袍瘿茚祓栳┹莛狎糸犰茚祓栳茯殓梏萁荛铘啕暨饼摞暨昌莒彐舁苕蜥沱莛狎糸犰茔犰忑莛狎糸犰颀苕蜥沱莛狎糸犰颀莛狎糸犰茚祓栳苕蜥沱莛狎糸犰茔犰听莛狎糸犰茕雉颀苕蜥沱莛狎糸犰茕雉颀莛狎糸犰茚祓栳茯殓梏╀舢い拣睛钼箴患怛族栳鲥溴骈铄拣睛钼箴患怛い苕蜥沱莛狎糸犰瘿茚祓栳莛狎糸犰茚祓栳杰弭屺い拣睛钼箴患怛犷翳弪邂拣睛钼箴患怛い苕蜥沱莛狎糸犰茕雉颀衄茚祓栳莛狎糸犰茚祓栳杰骝徙洙苠翎舂漪い拣睛钼箴患怛集箦泗轱罹俭邈糸镱艰殇舰轭翦珧狒轭绛怡疳螋螈旧昔彗蜥糸铉怡嗅螋集璨拣阵轭拣睛钼箴患怛い苕蜥沱莛狎糸犰瘿衄茚祓栳莛狎糸犰茚祓栳杰弭屺舂い拣睛钼箴患怛拣犷拣睛钼箴患怛い苕蜥沱莛狎糸犰茕雉颀衄茚祓栳莛狎糸犰茚祓栳杰骝徙洙苠翎舂漪い拣睛钼箴患怛拣轭翳轭翦珧犰玳鲥拣睛钼箴患怛い莒彐糅苕蜥沱莛狎糸犰盂瘿茚祓栳┹莛狎糸犰茚祓栳茯殓梏萁荛铘啕暨饼摞暨昌莒彐舁苕蜥沱莛狎糸犰茔犰听莛狎糸犰颀苠翎舂苕蜥沱莛狎糸犰茔犰听莛狎糸犰茕雉颀苕蜥沱洙苠翎舂漪茯殓梏╀舢い拣睛钼箴患怛拣深翦珧狒轭翳箦泔钿翦蝽怡疳螋拣睛钼箴患怛い荛铘啕暨饼摞暨昌苕蜥沱莛狎糸犰茔犰听莛狎糸犰茕雉颀苕蜥沱洙苠翎舂漪漪杰弭屺舂苕蜥沱莛狎糸犰茔犰听莛狎糸犰茕雉颀啕暨饼摞暨昌荛铘哚掴苠翎舂苕蜥沱潺澍苕蜥沱莛狎糸犰茔犰听莛狎糸犰茕雉颀漪い拣睛钼箴患怛拣犷箝钽翳骈蝮翦蝽溟篌狃疱狎漉麸塄苠翎ㄡ┙苠翎ㄢ┙堠麇镡翎轭拣睛钼箴患怛い莒彐糅苕蜥沱莛狎糸犰盂瘿茚祓栳┹莛狎糸犰茚祓栳茯殓梏萁荛铘啕暨饼摞暨昌莒彐舁苕蜥沱莛狎糸犰茔犰听莛狎糸犰颀苕蜥沱潺澍苕蜥沱莛狎糸犰茔犰听莛狎糸犰茕雉颀茯殓梏┸弭屺舂漪桨い拣睛钼箴患怛集箦泗轱罹俭邈糸镱艰殇舰艴戾颦灬珧犷珏羼踽糸镱螈九蹯弪提珧犷珏篷踽糸镱集璨拣澡灬趑弪汜忮黩轸翦狍拣睛钼箴患怛い莒彐糅苕蜥沱莛狎糸犰盂瘿茚祓栳┹莛狎糸犰茚祓栳茯殓梏葸茚祓栳桨杰轭暨暨饼摞暨昌莒彐舁苕蜥沱莛狎糸犰茔犰听莛狎糸犰颀苕蜥沱潺澍苕蜥沱莛狎糸犰茔犰听莛狎糸犰茕雉颀茯殓梏┸溴祠瘿舂漪杰溴祠爱い拣睛钼箴患怛拣澡泔钿轸轱骘篝狒轱钺蝙鲠祯轶翳躞疳螋獒溟骀弪孱糸犰羼踽糸镱拣睛钼箴患怛い苕蜥沱莛狎糸犰茔犰听莛狎糸犰颀苕蜥沱潺澍苕蜥沱莛狎糸犰茔犰听莛狎糸犰茕雉颀桨い拣睛钼箴患怛拣腩秣狍翳尖九蹯弪提珧犷珏集饩羼踽糸镱集箦泗轱罹俭邈糸镱艰殇舰泔铙趄衢铄洵盹糸镱⒕蔑铙趄衢铄盹糸镱集璨拣语礤糸礤犷狨殪獒蝙泔铙趄衢铘轶徜溴麸翳痱镡戾ㄢ妁镱骈轭翳孱痫轸塄弑堠犷塄卟堠┊术篝徼遽洮麇鏖祆黠螂镱翳屮犴痨镦栳铉轭汨衢町澡箬狃镦翳沲蝣黹铋黹弩翳痫翦铘獒孱弪琦躅溴翳泔铙趄衢铘镦骈邃戾铉翳镦汨衢町洛骘蝈痱弩孱糸铉篚汨犷屮犴痨麇骈蝮蝈鲩鬻翳礤翳镤镦提珧犷珏眭祠轲扉弪狍礤翳镤骘骈钿轭黹铋磲矧磲轫躅溴泔铙趄衢铘螽拣身徵轭骢钽糸镱塄妯弑卟茔滹趔哳堠骘麒殂秕鏖箬麸骈钿翳黹铋磲龄溟糸镱犰禊秕狎玳鲥泔铙趄衢铘拣睛钼箴患怛い茆彗轭羼钺蝌狴猫弑茔滹趔哳┙苠钿羼钺蝌狴い拣睛钼箴患怛集箦泗轱罹俭邈糸镱艰殇舰泔铙趄衢铄洵盹糸镱泔钿轸轱瞽骘颦岘黹铋眭恝久镱篝蜥轭邃盹糸镱蔑钿轸轱骘烷铋眭集璨拣澡躞踽泔钿轸轱骘黹铋眭轶拣睛钼箴患怛い茆彗轭羼钺蝌狴苕蜥沱莛狎糸犰纨莛狎糸犰唛桨茯矧\nabla f=0.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
which would be \( n \) equations for the \( n \) variables. The gradient of a
scalar is a vector, so you should think of \( \nabla \) as
\( \boldsymbol{\nabla} \). However, the solution will likely not satisfy the
constraint, i.e. the point at which \( f(x_1\cdots x_n) \) has an extrema,
may not be a point where \( C(x_1\cdots x_n)=0 \).
</section>


<section>
<h2 id="constrained-motion-necessary-conditions">Constrained motion, Necessary Conditions  </h2>

<p>
A necessary condition for the solution is that

<p>&nbsp;<br>
$$
\begin{equation}
\nabla f\cdot\boldsymbol{\epsilon}=0,
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>

<p>
for any infinitesimal vector \( \boldsymbol{\epsilon} \) if \( \boldsymbol{\epsilon} \)
satisfies the condition

<p>&nbsp;<br>
$$
\begin{equation}
\delta C=\nabla C\cdot\boldsymbol{\epsilon}=0.
\tag{2}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="constrained-motion">Constrained motion </h2>

<p>
That is to say if I take a small step in a direction that doesn't
change the constraint, then \( f \) must not change if it is an
extrema. Not changing the constraint implies the step is orthogonal to
\( \nabla C \). As there are \( n \) dimensions of \( x \), the vector \( \nabla C \)
defines one direction, and \( \boldsymbol{\epsilon} \) can be in any of the \( n-1 \)
directions orthogonal to \( \nabla C \). If \( \nabla f\cdot\boldsymbol{\epsilon}=0 \)
for ANY of the \( n-1 \) directions of \( \boldsymbol{\epsilon} \) orthogonal to
\( \nabla C \), then

<p>&nbsp;<br>
$$
\begin{equation}
\nabla f || \nabla C.
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Because the two vectors are parallel you can say there must exist some
constant \( \lambda \) such that

<p>&nbsp;<br>
$$
\begin{equation}
\nabla(f-\lambda C)=0.
\tag{4}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="constrained-motion-lagrange-multiplier">Constrained motion, Lagrange Multiplier  </h2>

<p>
Here, \( \lambda \) is known as a Lagrange multiplier. Satisfying
this equation  is a necessary, but not a sufficient
condition. One could add a constant to the constraint and the gradient
would not change. One must find the correct value of \( \lambda \) that
satisfies the constraint \( C=0 \), rather than \( C= \) some other
constant. The strategy is then to solve
thw above equation  then adjust \( \lambda \) until one
finds the \( x_1\cdots x_n \) that gives \( C(x_1\cdots x_n)=0 \).

<p>
The method of Lagrange multipliers is counter-intuitive to one's
intuition to use the constraint to reduce the dimensionality of the
problem. Normally, minimizing a function of \( n \) variables, leads to
\( n \) equations and \( n \) unknowns. A constraint could be used, by
substitution, to replace the \( n \) variables with \( n-1 \)
variables. Instead, we add an unknown parameter, \( \lambda \), and change
the equation to \( n+1 \) equations with \( n+1 \) unknowns, with the extra
unknown being the Lagrange multiplier \( \lambda \). Often, it is rather
easy to solve for \( x_1\cdots x_n \). Then one is left with the usually
difficult problem of finding \( \lambda \), often requiring the solution
of a transcendental equation.
</section>


<section>
<h2 id="lagrange-multipliers">Lagrange Multipliers  </h2>

<p>
Let us try to formalize this. We consider a function of three independent variables \( f(x,y,z) \) . For
the function \( f \) to be an extreme we have

<p>&nbsp;<br>
$$
df=0.
$$
<p>&nbsp;<br>

<p>
A necessary and sufficient condition is

<p>&nbsp;<br>
$$
\frac{\partial f}{\partial x} =\frac{\partial f}{\partial y}=\frac{\partial f}{\partial z}=0,
$$
<p>&nbsp;<br>

<p>
due to

<p>&nbsp;<br>
$$
df = \frac{\partial f}{\partial x}dx+\frac{\partial f}{\partial y}dy+\frac{\partial f}{\partial z}dz.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="independent-variables">Independent Variables </h2>

<p>
In physical problems the variables \( x,y,z \) are often subject to constraints (in our case \( q \) and the orthogonality constraint)
so that they are no longer all independent. It is possible at least in principle to use each constraint to eliminate one variable
and to proceed with a new and smaller set of independent varables.

<p>
The use of so-called Lagrangian  multipliers is an alternative technique  when the elimination of
of variables is incovenient or undesirable.  Assume that we have an equation of constraint on the variables \( x,y,z \)

<p>&nbsp;<br>
$$
\phi(x,y,z) = 0,
$$
<p>&nbsp;<br>

<p>
 resulting in

<p>&nbsp;<br>
$$
d\phi = \frac{\partial \phi}{\partial x}dx+\frac{\partial \phi}{\partial y}dy+\frac{\partial \phi}{\partial z}dz =0.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="more-on-independent-variables">More on Independent Variables </h2>

<p>
Now we cannot set anymore

<p>&nbsp;<br>
$$
\frac{\partial f}{\partial x} =\frac{\partial f}{\partial y}=\frac{\partial f}{\partial z}=0,
$$
<p>&nbsp;<br>

<p>
if \( df=0 \) is wanted
because there are now only two independent variables!  Assume \( x \) and \( y \) are the independent variables.
Then \( dz \) is no longer arbitrary.

<p>
However, we can add to

<p>&nbsp;<br>
$$
df = \frac{\partial f}{\partial x}dx+\frac{\partial f}{\partial y}dy+\frac{\partial f}{\partial z}dz,
$$
<p>&nbsp;<br>

<p>
a multiplum of \( d\phi \), viz. \( \lambda d\phi \), resulting  in

<p>&nbsp;<br>
$$
df+\lambda d\phi = (\frac{\partial f}{\partial z}+\lambda\frac{\partial \phi}{\partial x})dx+(\frac{\partial f}{\partial y}+\lambda\frac{\partial \phi}{\partial y})dy+(\frac{\partial f}{\partial z}+\lambda\frac{\partial \phi}{\partial z})dz =0.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="choice-of-multiplier">Choice of Multiplier  </h2>

<p>
Our multiplier is chosen so that

<p>&nbsp;<br>
$$
\frac{\partial f}{\partial z}+\lambda\frac{\partial \phi}{\partial z} =0.
$$
<p>&nbsp;<br>

<p>
However, we took \( dx \) and \( dy \) as to be arbitrary and thus we must have

<p>&nbsp;<br>
$$
\frac{\partial f}{\partial x}+\lambda\frac{\partial \phi}{\partial x} =0,
$$
<p>&nbsp;<br>

<p>
and

<p>&nbsp;<br>
$$
\frac{\partial f}{\partial y}+\lambda\frac{\partial \phi}{\partial y} =0.
$$
<p>&nbsp;<br>

<p>
When all these equations are satisfied, \( df=0 \).  We have four
unknowns, \( x,y,z \) and \( \lambda \). Actually we want only \( x,y,z \),
\( \lambda \) need not to be determined, it is therefore often called
Lagrange's undetermined multiplier.  If we have a set of constraints
\( \phi_k \) we have the equations

<p>&nbsp;<br>
$$
\frac{\partial f}{\partial x_i}+\sum_k\lambda_k\frac{\partial \phi_k}{\partial x_i} =0.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="example-brachiostone-i">Example: brachiostone I </h2>

<p>
Consider a particle constrained to move along a path (like a bead
moving without friction on a wire) and you need to design a path from
\( x=y=0 \) to some final point \( x_f,y_f \). Assume there is a constant
force in the \( x \) direction, \( F_x=mg \). Design the path so that the time
the bead travels is a minimum.

<p>
The net time is

<p>&nbsp;<br>
$$
T=\int \frac{d\ell}{v}=\int_0^{x_f} dx\frac{\sqrt{1+y'^2}}{\sqrt{2gx}}={\rm minimum}.
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="example-brachiostone-ii">Example: brachiostone II </h2>

<p>
Here we made use of the fact that \( d\ell=\sqrt{dx^2+dy^2} \) and that
the velocity is determined by \( KE=mv^2/2=mgx \). The Euler equations can
be applied if you first define the function as

<p>&nbsp;<br>
$$
\begin{eqnarray*}
f(y,y';x)&=&\frac{\sqrt{1+y'^2}}{\sqrt{x}}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The equations are then

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\frac{d}{dx}\frac{\partial f}{\partial y'}&=&0.
\end{eqnarray*}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="example-brachiostone-iii">Example: brachiostone III </h2>

<p>
The simplification ensued from \( f \) not having any dependence on \( y \). This yields the differential equation

<p>&nbsp;<br>
$$
\begin{eqnarray}
\frac{y'}{x^{1/2}(1+y'^2)^{1/2}}&=&(2a)^{-1/2},
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
because \( \partial f/\partial y' \) must be a constant, which with some
foresight we label \( (2a)^{-1/2} \). One can now solve for \( y' \),

<p>&nbsp;<br>
$$
\begin{eqnarray*}
(y')^2&=&2ax(1+y'^2)\\
\nonumber
y'&=&\sqrt{\frac{x}{2a-x}},\\
\nonumber
y(t)&=&\int_0^x dx'\frac{\sqrt{x'}dx'}{\sqrt{2a-x'}}=\int_0^x dx'\frac{x'dx'}{\sqrt{2ax'-x'^2}}\\
\nonumber
&=&\frac{1}{2}\int_0^x\frac{(2x'-2a)dx'}{(2ax'-x'^2)^{1/2}}+a\int_0^x\frac{dx'}{\sqrt{2ax'-x'^2}}\\
\nonumber
&=&\frac{-1}{2}\int_0^{2ax-x^2}\frac{du}{\sqrt{u}}+a\int_0^x\frac{dx'}{\sqrt{a^2-(x'-a)^2}}\\
&=&-\sqrt{2ax-x^2}+a\cos^{-1}(1-x/a).
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
This turns out to be the equation for a {\it cycloid} or a {\it
brachiostone}. If you rolled a wheel of radius \( a \) down the \( y \) axis
and followed a point on the rim, it would trace out a cycloid. Here,
the constant \( a \) must be chosen to match the boundary condition,
\( y_2=y(x_2) \). You can see the textbook for more details, plus you get
a chance to work with cycloids in the exercises at the end of this
chapter.
</section>


<section>
<h2 id="maximizing-a-function">Maximizing a Function  </h2>

<p>
As an example of using Lagrange multipliers for a standard
optimization formula we attempt to maximize the following function,

<p>&nbsp;<br>
$$
F(x_1\cdots x_n)=-\sum_{i=1}^n x_i\ln(x_i), 
$$
<p>&nbsp;<br>

<p>
with respect to the \( n \) variables \( x_i \). With no constraints, each
\( x_i \) would maximize the function for

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\frac{d}{dx_j}\left[-\sum_i x_i\ln(x_i)\right]&=&0\\
-\ln(x_j)-1&=&0,~~x_j=e^{-1}.
\end{eqnarray*}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="two-constraints">Two Constraints </h2>

<p>
Now, we repeat the problem but with two constraints,

<p>&nbsp;<br>
$$
\sum_ix_i=1,~~\sum_ix_i\epsilon_i=E.
$$
<p>&nbsp;<br>

<p>
Here, \( \epsilon_i \) and \( E \) are fixed constants. We go forward by
finding the extrema for

<p>&nbsp;<br>
$$
\begin{eqnarray*}
G(x_1\cdots x_n)&=&F-\alpha\sum_i x_i-\beta\sum_i\epsilon_ix_i
=\sum_i \left\{-x_i\ln(x_i)-\alpha x_i-\beta\epsilon_ix_i\right\}.
\end{eqnarray*}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="two-multipliers">Two Multipliers </h2>

<p>
There are two Lagrange multipliers, \( \alpha \) and \( \beta \),
corresponding to the two constraints. One then solves for the extrema

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\frac{d}{dx_j}G&=&0\\
&=&-\ln(x_j)-1-\alpha-\beta\epsilon_j,\\
x_j&=&\exp\left\{-1-\alpha-\beta\epsilon_j\right\}.
\end{eqnarray*}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="lagrange-multipliers">Lagrange multipliers </h2>

<p>
For any given \( \alpha \) and \( \beta \) this provides a solution for
constraining \( \sum_i x_i \) and \( \sum_i\epsilon_ix_i \) to some values,
just not the values of unity and \( E \) that you wish. One would then
have to search for the correct values by adjusting \( \alpha \) and
\( \beta \) until the constraint are actually matched by solving a
transcendental equation. Although this can be complicated, it is
certainly less expensive than searching over all \( N \) values of
\( x_i \). This particular example corresponds to maximizing the entropy
for a system, \( S=-\sum_i x_i\ln(x_i) \), where \( x_i \) is the probability
of the system being in a particular discrete level \( i \) that has energy
\( \epsilon_i \). One wishes to maximize the entropy subject to the
constraints that the probabilities sum to unity and the average energy
has some given value. The result that \( x_i\sim e^{-\beta\epsilon_i} \)
demonstrates the origin of the Boltzmann factor, with the inverse
temperature \( \beta=1/T \).
</section>


<section>
<h2 id="lagrange-multipliers">Lagrange multipliers </h2>

<p>
Lagrange multipliers also assist with the Euler-Lagrange equation. If
one breaks an interval \( x_1 < x < x_2 \) into a large number
\( n\rightarrow\infty \) points separated by \( dx \), the Euler-Lagrange
equation involves finding the \( n \) values \( y_i \) at each point so that
\( \sum_i dx f\left\{y_i,y'_i=(y_{i+1}-y_{i-1})/(2dx)\right\} \) is
maximized for some given function \( f \). If an additional auxiliary
constraint is added, also some function of the \( n \) values \( y_i \), one
can use the method of Lagrange multipliers. In the constraint can also
be written as some function of \( C(y_i,y'_i) \), then one simply adds a
term \( \lambda C(y,y') \) to the function \( f \) and uses the Euler-Lagrange
equation to find the extrema of.

<p>&nbsp;<br>
$$
\begin{eqnarray}
J&=&\int_{x_1}^{x_2}dxf\left\{y(t),y'(t),x\right\}-\lambda C\left\{y(t),y'(t),x\right\},
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
the one difference being that

<p>&nbsp;<br>
$$
\begin{equation}
f\left\{y(t),y'(t),x\right\}\rightarrow f\left\{y(t),y'(t),x\right\}-\lambda C\left\{y(t),y'(t),x\right\}
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="example">Example </h2>

<p>
Consider a chain of length \( L \) and mass per unit length \( \kappa \) that
hangs from point \( x=0,y=0 \) to point \( x_f,y_f \). The shape must minimize
the potential energy. Find general expressions for the shape in terms
of three constants which must be chosen to match \( y(0)=0, y(x_f)=y_f \)
and the fixed length. Equivalently, one finds the function \( y(t) \) that
provides an extrema for the integral,

<p>
One must minimize

<p>&nbsp;<br>
$$
\int d\ell\kappa gy-\lambda\int d\ell=
\int_0^{x_f} dx\sqrt{1+y'^2}\kappa gy-\lambda \int_0^{x_f} dx\sqrt{1+y'^2}.
$$
<p>&nbsp;<br>

<p>
Here \( \lambda \) is the Lagrange multiplier associated with constraining
the length of the chain. The constrained length \( L \) appears nowhere in
the expression. Instead, one solves for form of the answer, then
adjusts \( \lambda \) to give the correct length. For the purposes of the
Euler-Lagrange minimization one considers the function

<p>&nbsp;<br>
$$
\begin{eqnarray}
f(y,y';x)&=&\kappa gy\sqrt{1+y'^2}-\lambda\sqrt{1+y'^2}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
Because \( \lambda \) is an unknown constant and because minimizing a
function multiplied by a constant is the same as minimizing the
function, we can equivlently minimize the integral using the function

<p>&nbsp;<br>
$$
\begin{eqnarray}
\tilde{f}(y,y';x)&=&y\sqrt{1+y'^2}-\tilde{\lambda}\sqrt{1+y'^2},\\
\nonumber
\tilde{\lambda}&\equiv&\frac{\lambda}{\kappa g}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
The Euler-Lagrange equations then become

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\frac{d}{dx}\left\{
\frac{y'}{\sqrt{1+y'^2}}y-\tilde{\lambda}\frac{y'}{\sqrt{1+y'^2}}
\right\}&=&\sqrt{1+y'^2}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Here, we will guess at the form of the solution,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
y'&=&\sinh[(x-x_0)/a],~y=a\cosh[(x-x_0)/a]+y_0.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Plugging into the Euler-Lagange equations,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\frac{d}{dx}\left\{(a\cosh[(x-x_0)/a]+y_0)\frac{\sinh[(x-x_0)/a]}{\cosh[(x-x_0)/a]}-\tilde{\lambda}\frac{\sinh[(x-x_0)/a]}{\cosh[(x-x_0)/a]}\right\}&=&\cosh[(x-x_0)/a],\\
\nonumber
\frac{d}{dx}\left\{(y_0-\tilde{\lambda})\tanh[(x-x_0)/a]\right\}=0.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
This solution works if \( y_0=\tilde{\lambda} \). So the general form of
the solution is

<p>&nbsp;<br>
$$
y=\tilde{\lambda}+a\cosh[(x-x_0)/a].
$$
<p>&nbsp;<br>

<p>
One must find \( \tilde{\lambda} \), \( x_0 \) and \( a \) to satisfy three
conditions, \( y(x=0)=0 \), \( y(x=x_f)=y_f \) and that the length is \( L \). For
a hanging chain \( a \) is positive. A solution with negative \( a \) would
represent a maximum of the potential energy. A remarkable property of
the solution is that once you define the length and the end-point
positions \( y_1 \) and \( y_2 \), the solution does not depend on \( \kappa \) or
\( g \). Thus, the shape of the chain would be the same if you took it to
the moon. These solutions are known as <a href="http://en.wikipedia.org/wiki/Catenary}{http://en.wikipedia.org/wiki/Catenary" target="_blank">catenaries</a>.

<h2 id="lagrangians">Lagrangians </h2>

<p>
Lagrangians represent a powerful method for solving problems that
would be nearly impossible by direct application of Newton's third
law, \( \boldsymbol{F}=m\boldsymbol{a} \). The method works well for problems where a
system is well described by a few \textit{generalized coordinates}. A
generalized coordinate might be the angle describing the position of a
pendulum. This one angle takes the place of using \( x \) and \( y \) to
describe the position of the pendulum, then applying a clumsy
constraint.

<p>
The Lagrangian equations of motion can be derived from a principle of
least action, where the action \( S \) is defined as

<p>&nbsp;<br>
$$
\begin{equation}
S=\int dt L(q,\dot{q},t),
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>

<p>
where \( q \) is some coordinate that describes the orientation of a
system and the Lagrangian \( L \) is defined as

<p>&nbsp;<br>
$$
\begin{equation}
L=T-U,
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>

<p>
the difference of the kinetic and potential energies. Minimizing the
action through the Euler-Lagrange equations gives the Lagrangian
equations of motion,

<p>&nbsp;<br>
$$
\begin{equation}
\frac{d}{dt}\frac{\partial L}{\partial \dot{q}}=\frac{\partial L}{\partial q}.
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>

<p>
We begin with two simple examples, neither of which gains from the Lagrangian approach.

<p>
Consider a particle of mass \( m \) connected to a spring with stiffness \( k \). Derive the Lagrangian equations of motion.

<p>&nbsp;<br>
$$
\begin{eqnarray*}
L&=&\frac{1}{2}m\dot{x}^2-\frac{1}{2}kx^2,\\
\frac{d}{dt}\frac{\partial L}{\partial \dot{x}}&=&\frac{\partial L}{\partial x},\\
m\ddot{x}&=&-kx.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Derive the Lagrangian equations of motion for a pendulum of mass \( m \)
and length \( \ell \).

<p>&nbsp;<br>
$$
\begin{eqnarray*}
L&=&\frac{m}{2}\ell^2\dot{\theta}^2-mg\ell(1-\cos\theta),\\
\frac{d}{dt}\frac{\partial L}{\partial \dot{\theta}}&=&\frac{\partial L}{\partial \theta},\\
m\ell^2\ddot{\theta}&=&-mg\ell\sin\theta,\\
\ddot{\theta}&=&-\frac{g}{\ell}\sin\theta,\\
\ddot{\theta}&\approx&-\frac{g}{\ell}\theta.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<h3 id="proving-lagrange-s-equations-of-motion-from-newton-s-laws">Proving Lagrange's Equations of Motion from Newton's Laws </h3>

<p>
Lagrange's equations of motion can only be applied for the following conditions:

<ul>
<p><li> The potential energy is a function of the generalized coordinates \( q_i \), but not of \( \dot{q}_i \).</li>
<p><li> The relation between the original coordinates \( x,y,z\cdots \) and the generalized coordinates does not depend on \( \dot{q}_i \), e.g. \( x(q,t) \) not \( x(q,\dot{q},t) \).</li>
<p><li> Any constraints used to reduce the number of degrees of freedom are functions of \( \boldsymbol{q} \), but not of \( \dot{\boldsymbol{q}} \).</li>
<p><li> The motion is not dissipative (no damping or friction).</li>
</ul>
<p>

Going forward with the proof, consider \( x_i(q_1,q_2\cdots,t) \) and look
at the l.h.s. of Lagrange's equations of motion.

<p>&nbsp;<br>
$$
\begin{eqnarray}
\frac{\partial T}{\partial\dot{q}_j}&=&\sum_i\frac{\partial T}{\partial\dot{x}_i}\frac{\partial\dot{x}_i}{\partial\dot{q_j}}
+\sum_i\frac{\partial T}{\partial x_i}\frac{\partial x_i}{\partial\dot{q_j}}\\
\nonumber
&=&\sum_i m\dot{x}_i\frac{\partial \dot{x}_i}{\partial\dot{q_j}}\\
\nonumber
&=&\sum_i m\dot{x}_i\frac{(\delta x_i/\delta t)|_{{\rm fixed}q_{j'\ne j}}}{\delta q_j/\delta t}\\
\nonumber
&=&\sum_im\dot{x}_i\frac{\delta{x}_i|_{{\rm fixed}q_{j'\ne j}}}{\delta q_j}\\
\nonumber
&=&\sum_i m\dot{x}_i\frac{\partial x_i}{\partial q_j}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
In the first line we used the fact that \( T \) does not depend on
\( x \). Continuing with taking the derivative of \( U \),

<p>&nbsp;<br>
$$
\begin{eqnarray}
-\frac{\partial U}{\partial\dot{q}_j}&=&-\sum_i\frac{\partial U}{\partial x_i}\frac{\partial x_i}{\partial\dot{q}_j}=0.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
In the first line above we used the fact that \( U \) does not depend on \( \dot{x} \) then we used the second condition that \( x \) does not depend on \( \dot{q} \). Adding the two pieces together, then taking the derivative w.r.t. time,

<p>&nbsp;<br>
$$
\begin{eqnarray}
\nonumber
\frac{d}{dt}\frac{\partial}{\partial\dot{q}}(T-U)&=&\sum_im\ddot{x}_i\frac{\partial x_i}{\partial q_j}
+\sum_i m\dot{x}_i\frac{\partial\dot{x}_i}{\partial q_j}.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
Now, we consider the r.h.s. of Lagrange's equations. Because the
kinetic energy depends only on \( \dot{x} \) and not \( x \), and because the
potential depends on \( x \) but not \( \dot{x} \),

<p>&nbsp;<br>
$$
\begin{eqnarray}
\frac{\partial}{\partial q_j}(T-U)&=&\sum_i\frac{\partial T}{\partial\dot{x}_i}\frac{\partial\dot{x_i}}{\partial q_j}
-\sum_i\frac{\partial U}{\partial x_i}\frac{\partial x_i}{\partial q_j}\\
\nonumber
&=&\sum_i m\dot{x}_i\frac{\partial\dot{x_i}}{\partial q_j}
-\sum_i\frac{\partial U}{\partial x_i}\frac{\partial x_i}{\partial q_j}
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
Using the fact that \( m\ddot{x}_i=-(\partial/\partial x_i)U \), one can
see that the bottom expressions above are identical,

<p>&nbsp;<br>
$$
\begin{equation}
\frac{d}{dt}\frac{\partial}{\partial\dot{q}_i}(T-U)=\frac{\partial}{\partial q_i}(T-U).
\tag{9}
\end{equation}
$$
<p>&nbsp;<br>

<h3 id="lagrangian-examples">Lagrangian Examples </h3>

<p>
Two examples are presented here. In the first, there are two
generalized coordinates, but the two equations of motion can be
reduced to one through conservation laws (angular momentum in this
case). In the second, there is a time-dependent constraint.

<p>
Consider a cone of half angle \( \alpha \) standing on its tip at the
origin. The surface of the cone is defined as

<p>&nbsp;<br>
$$
r=\sqrt{x^2+y^2}=z\tan \alpha.
$$
<p>&nbsp;<br>

<p>
Find the equations of motion for a particle of mass \( m \) moving along the surface under the influence of a constant gravitational force, \( -mg\hat{z} \). For generalized coordinates use the azimuthal angle \( \phi \) and \( r \).

<p>
The kinetic energy is

<p>&nbsp;<br>
$$
\begin{eqnarray*}
T&=&\frac{1}{2}mr^2\dot{\theta}^2+\frac{1}{2}m(\dot{r}^2+\dot{z}^2)\\
&=&\frac{1}{2}mr^2\dot{\theta}^2+\frac{1}{2}m\dot{r}^2\left(1+\cot^2\alpha\right)\\
&=&\frac{1}{2}mr^2\dot{\theta}^2+\frac{1}{2}m\dot{r}^2\csc^2\alpha.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The potential energy is

<p>&nbsp;<br>
$$
U=mgr\cot\alpha,
$$
<p>&nbsp;<br>

<p>
so Lagrange's equations give

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\frac{d}{dt}\left(mr^2\dot{\theta}\right)&=&0,\\
\frac{d}{dt}\left(m\csc^2\alpha \dot{r}\right)&=&mr\dot{\theta}^2-mg\cot\alpha,\\
\ddot{r}&=&r\dot{\theta}^2\sin^2\alpha-g\cos\alpha\sin\alpha
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The first equation is a statement of the conservation of angular
momentum with \( L=mr^2\dot{\theta} \), so the second equation can also be
expressed as

<p>&nbsp;<br>
$$
\ddot{r}=\frac{L^2\sin^2\alpha}{m^2r^3}-g\sin\alpha\cos\alpha.
$$
<p>&nbsp;<br>

<p>
A bead slides along a wire bent in the shape of a parabola,

<p>&nbsp;<br>
$$
z=\frac{1}{2}kr^2,~r^2=x^2+y^2.
$$
<p>&nbsp;<br>

<p>
Also, the parabolic wire is rotating about the \( z \) axis with angular
velocity \( \omega \). Derive the equations of motion. Are there any
stable configurations?

<p>
Using the fact that

<p>&nbsp;<br>
$$
\dot{z}=\dot{r}\frac{\partial z}{\partial r}=kr\dot{r},
$$
<p>&nbsp;<br>

<p>
the kinetic and potential energies are

<p>&nbsp;<br>
$$
\begin{eqnarray*}
T&=&\frac{1}{2}m\left(\dot{r}^2+\dot{z}^2+r^2\omega^2\right)\\
&=&\frac{1}{2}m\left(\dot{r}^2+(kr\dot{r})^2+r^2\omega^2\right),\\
U&=&mgkr^2/2.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The equations of motion are then

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\frac{d}{dt}\left\{m\dot{r}(1+k^2r^2)\right\}&=&-mgkr+mk^2\dot{r}^2r+m\omega^2r,\\
\ddot{r}&=&\frac{-gkr+\omega^2r-k^2\dot{r}^2r}{1+k^2r^2}
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
For a stable configuration, there needs to be a solution with
\( \dot{r}=0 \) and \( \ddot{r}=0 \). This can only happen at \( r=0 \), and then
for the acceleration to be inward for small deviations of \( r \) one
needs to have \( gk>\omega^2 \). If \( \omega^2>gk \) the bead will move
outward indefinitely.

<h2 id="small-vibrations-and-normal-modes">Small Vibrations and Normal Modes </h2>

<p>
Two examples are provided for solving for normal modes. These are
solutions with multiple generalized coordinates, where the motion is
that of simple harmonic motion. However, the motion is only simple for
a particular set of coordinates \( q_1 \) and \( q_2 \),

<p>&nbsp;<br>
$$
\begin{eqnarray}
q_1&=&A\cos(\omega_1 t),\\
\nonumber
q_2&=&B\cos(\omega_2 t),
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
while it is not necessarily simple in other coordinates. For example
if \( x=q_1+q_2 \), and \( y=q_1-q_2 \), the \( x \) and \( y \) motions will contain
mixtures of multiple frequencies. For many problems, or in the limit
of small vibrations about a minimum, there is some coordinate system
where the motion is simple. These are normal modes. Characterizing the
normal modes involves finding the frequencies, \( \omega_i \), and the
coordinate system where the motion is simple for each coordinate. This
involves finding the direction, or the linear combination of \( x_i \)
that form the coordinates \( q_i \) in which the motion is that of a
single oscillator in each coordinate.

<p>
For a first example, we consider a system of springs, where we write
the Lagrangian, then find the normal modes. For the second example, a
double pendulum is considered. In this case, one must first make a
small angle expansion before finding the modes. In principle, problems
could have the same number of normal modes a degrees of freedom. For
example, a system of 7 particles moving in three dimensions has 21
degrees of freedom. However, some of the degrees of freedom do not
have oscillatory behavior. For example, for a rigid body in free
space, the angles describing the orientation evolve, but do not
oscillate. Also, the center-of-mass coordinates of a system of
particles isolated from outside particles moves at constant
velocity. One can also describe these as normal modes, but acknowledge
that their characteristic frequency is zero, as there are no restoring
forces.

<p>
Consider two springs, whose relaxed lengths are \( \ell \), connected to three masses as depicted in the figure here. Describe the two normal modes of the motion. We can write the Lagrangian as

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\mathcal{L}&=&\frac{m}{2}\dot{x}_1^2+m\dot{x}_2^2+\frac{m}{2}\dot{x}_3^2
-\frac{k}{2}(x_2-x_1-\ell)^2-\frac{k}{2}(x_3-x_2-\ell)^2.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
There are three coordinates, thus there are three equations of motion,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
m\ddot{x}_1&=&-k(x_1-x_2+\ell)\\
2m\ddot{x}_2&=&-k(x_2-x_1-\ell)-k(x_2-x_3+\ell)\\
&=&-k(2x_2-x_1-x_3)\\
m\ddot{x}_3&=&-k(x_3-x_2+\ell).
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
This is a bit complicated because the center-of-mass motion does not easily separate from the three equations. Instead, choose the following coordinates,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
X&=&\frac{x_1+2x_2+x_3}{4},\\
q_1&=&x_1-x_2+\ell,\\
q_3&=&x_3-x_2-\ell.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
In these coordinates the potential energy only involves two coordinates,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
U&=&\frac{k}{2}(q_1^2+q_3^2).
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
To express the kinetic energy express \( x_1, x_2 \) and \( x_3 \) in terms of
\( X \), \( q_1 \) and \( q_3 \),

<p>&nbsp;<br>
$$
\begin{eqnarray*}
x_1&=&(3q_1-q_3-4\ell+4X)/4,\\
x_2&=&(4X-q_1-q_3)/4,\\
x_3&=&(3q_3-q_1+4\ell+4X)/4.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The kinetic energy and Lagrangian are them

<p>&nbsp;<br>
$$
\begin{eqnarray*}
T&=&\frac{m}{2}\frac{1}{16}(3\dot{q}_1-\dot{q}_3+4\dot{X})^2
+m\frac{1}{16}(4\dot{X}-\dot{q}_1-\dot{q}_3)^2
+\frac{m}{2}\frac{1}{16}(3\dot{q}_3-\dot{q}_1+4\dot{X})^2\\
&=&\frac{3m}{8}(\dot{q}_1^2+\dot{q}_3^2)-\frac{m}{4}\dot{q}_1\dot{q}_3
+2m\dot{X}^2,\\
\mathcal{L}&=&\frac{3m}{8}(\dot{q}_1^2+\dot{q}_3^2)-\frac{m}{4}\dot{q}_1\dot{q}_3
+2m\dot{X}^2-\frac{k}{2}q_1^2-\frac{k}{2}q_3^2.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The three equations of motion are then,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\frac{3}{4}m\ddot{q}_1-\frac{1}{4}m\ddot{q}_3&=&-kq_1,\\
\frac{3}{4}m\ddot{q}_3-\frac{1}{4}m\ddot{q}_1&=&-kq_3,\\
4M\ddot{X}&=&0.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The last equation simply states that the center-of-mass velocity is
fixed. One could obtain the same result by summing the equations of
motion for \( x_1 \), \( 2x_2 \) and \( x_3 \) above. The second two equations are
more complicated. To solve them, we assume a form

<p>&nbsp;<br>
$$
\begin{eqnarray*}
q_1&=&Ae^{i\omega t},\\
q_3&=&Be^{i\omega t},
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Because this is a linear equation, we can multiply the solution by a
constant and it will still be a solution. Thus, we can set \( B=1 \), then
solve for \( A \), effectively solving for \( A/B \). Putting this guess into
the equations of motion,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
-\frac{3}{4}\frac{A}{B}\omega^2+\frac{1}{4}\omega^2&=&-\omega_0^2\frac{A}{B},\\
-\frac{3}{4}\omega^2+\frac{1}{4}\frac{A}{B}\omega^2&=&-\omega_0^2.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
This is two equations and two unknowns, \( \omega^2 \) and
\( A/B \). Substituting for \( A/B \) gives a quadratic equation,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\omega^4-3\omega_0^2\omega^2+2\omega_0^4&=&0,\\
\omega_0^2&\equiv&k/m.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The two solutions are

<p>&nbsp;<br>
$$
\begin{eqnarray*}
(1)~\omega&=&\omega_0,~A=-B,\\
(2)~\omega&=&\omega_0\sqrt{2},~A=B.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
The first solution corresponds to the two outer masses moving in
opposite directions, in sync, with the middle mass fixed. The second
solution has both outer masses moving in the same direction, but with
the center mass moving opposite. These two solutions are referred to
as normal modes, and are characterized by their frequency and by the
linear combinations of coordinates that oscillate together. In
general, the solution is a linear combination of normal modes, which
usually results in a chaotic looking motion. However, once the
solution is expressed in terms of the normal modes, each of which
oscillates independently in a simple manner, one can better understand
the motion. Further, the frequencies of these modes represent the
natural resonant frequencies of the system. This is important in the
construction of many structures, such as bridges or vehicles.

<p>
Consider a double pendulum confined to the \( x-y \) plane, where \( y \) is
vertical. A mass \( m \) is connected to the ceiling with a massless
string of length \( \ell \). A second mass \( m \) hangs from the first mass
with an identical massless string of the same length. Using \( \theta_1 \)
and \( \theta_2 \) to describe the orientations of the strings relative to
the vertical axis, find the Lagrangian and derive the equations of
motion, both for arbitrary angles and in the small-angle
approximation. Finally, express the equations of motion in the limit
of small oscillations.

<p>
The kinetic and potential energies are:

<p>&nbsp;<br>
$$
\begin{eqnarray*}
T&=&\frac{1}{2}m\ell^2\dot{\theta}_1^2
+\frac{1}{2}m\left\{(\ell\dot{\theta}_1\cos\theta_1+\ell\dot{\theta}_2\cos\theta_2)^2
+(\ell\dot{\theta}_1\sin\theta_1+\ell\dot{\theta}_2\sin\theta_2)^2\right\}\\
&=&\frac{1}{2}m\ell^2\left\{2\dot{\theta}_1^2+\dot{\theta}_2^2+2\dot{\theta}_1\dot{\theta}_2\cos(\theta_1-\theta_2)
\right\},\\
U&=&mg\ell(1-\cos\theta_1)+mg\left[\ell(1-\cos\theta_1)+\ell(1-\cos\theta_2)\right]\\
&=&mg\ell(3-2\cos\theta_1-\cos\theta_2)
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Lagrange's equations for \( \theta_1 \) lead to

<p>&nbsp;<br>
$$
\begin{eqnarray*}
m\ell^2\frac{d}{dt}\left\{2\dot{\theta}_1+\dot{\theta}_2\cos(\theta_1-\theta_2)\right\}&=&
-m\ell^2\dot{\theta}_1\dot{\theta}_2\sin(\theta_1-\theta_2)
-2mg\ell\sin\theta_1,\\
2\ddot{\theta}_1+\ddot{\theta}_2\cos(\theta_1-\theta_2)+\dot{\theta}_2^2\sin(\theta_1-\theta_2)
&=&-2\omega_0^2\sin\theta_1,\\
\omega_0^2&\equiv& g/\ell,
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
and the equations for \( \theta_2 \) are

<p>&nbsp;<br>
$$
\begin{eqnarray*}
m\ell^2\frac{d}{dt}\left\{\dot{\theta}_2+\dot{\theta}_1\cos(\theta_1-\theta_2)\right\}&=&
m\ell^2\dot{\theta}_1\dot{\theta}_2\sin(\theta_1-\theta_2)-mg\ell\sin\theta_2,\\
\ddot{\theta}_2+\ddot{\theta_1}\cos(\theta_1-\theta_2)&=&
-\omega_0^2\sin\theta_2.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
For small oscillations, one can only consider terms linear in \( \theta_1 \) and \( \theta_2 \) or their derivatives,

<p>&nbsp;<br>
$$
\begin{eqnarray}
2\ddot{\theta}_1+\ddot{\theta}_2&=&-2\omega_0^2\theta_1,\\
\nonumber
\ddot{\theta}_1+\ddot{\theta}_2&=&-\omega_0^2\theta_2.
\end{eqnarray}
$$
<p>&nbsp;<br>

<p>
To find the solutions, assume they are of the form
\( \theta_1=Ae^{i\omega t}, \theta_2=Be^{i\omega t} \). Solve for \( \omega \)
and \( A/B \), noting that \( B \) is arbitrary.

<p>
Plug in the desired form and find

<p>&nbsp;<br>
$$
\begin{eqnarray*}
e^{i\omega t}(-2\omega^2A-\omega^2B)&=&e^{i\omega t}(-2\omega_0^2A),\\
e^{i\omega t}(-\omega^2A-\omega^2B)&=&e^{i\omega t}(-\omega_0^2B).
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
We can treat \( B \) as arbitrary and set it to unity. When we find \( A \),
it is the same as \( A/B \) for arbitrary \( B \). This gives the equations

<p>&nbsp;<br>
$$
\begin{eqnarray*}
2\omega^2A+\omega^2&=&2\omega_0^2A,\\
\omega^2A+\omega^2&=&\omega_0^2.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
This is two equations and two unknowns. Solving them leads to a
quadratic equation with solutions

<p>&nbsp;<br>
$$
\begin{eqnarray*}
A/B&=&\pm\frac{1}{\sqrt{2}},\\
\omega^2&=&\frac{\omega_0^2}{1\pm 1/\sqrt{2}}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Again, these two solutions are the normal modes, and the general
solution is a sum of the two solutions, with two arbitrary
constants. For the angles \( \theta_1 \) and \( \theta_2 \) are:

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\theta_1&=&\frac{A_+}{\sqrt{2}}e^{i\omega_+t}, \theta_2=A_+e^{i\omega_+t},\\
\theta_1&=&\frac{-A_-}{\sqrt{2}}e^{i\omega_-t}, \theta_2=A_-e^{i\omega_-t},\\
\omega_{\pm}&=&\omega_0\sqrt{\frac{1}{1\pm 1/\sqrt{2}}}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
One can also express the solution in vector notation, with the vectors
having arbitrary amplitudes \( A_+ \) and \( A_- \),

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\theta_+&=&\left(\begin{array}{c}
\frac{1}{\sqrt{2}}\\ 1\end{array}\right)A_+e^{i\omega_+t},\\
\theta_-&=&\left(\begin{array}{c}
\frac{-1}{\sqrt{2}}\\ 1\end{array}\right)A_-e^{i\omega_-t}.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Here, the upper/lower components of the vector describe
\( \theta_1/\theta_2 \) respectively.

<p>
These problems can be treated as linear algebra exercises. Linear
algebra is not used in this course, but nonetheless we describe how
this works for the curious student. In the limit of small vibrations,
the equations of motion can be expressed in the form,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
M\ddot{q}&=&-Kq,
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
a form that looks like the spring equation. However, \( q \) is an
$n-$dimensional vector and \( M \) and \( k \) are \( n\times n \) matrices. In
the double pendulum example, the dimensionality is 2 and the \( q \)
refers to the \( \theta_1 \) and \( \theta_2 \), and the matrices for \( M \) and
\( K \) can be read off (add ref).

<p>&nbsp;<br>
$$
\begin{eqnarray*}
M&=&\left(\begin{array}{cc}
2&1\\
1&1\end{array}\right),\hspace*{40pt} K=\left(\begin{array}{cc}
2\omega_0^2&0\\
0&\omega_0^2\end{array}\right).
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Multiplying both sides of the equation by the inverse matrix \( M^{-1} \),

<p>&nbsp;<br>
$$
\begin{eqnarray*}
\ddot{q}&=&-\left(M^{-1}K\right)q.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
Here,

<p>&nbsp;<br>
$$
\begin{eqnarray*}
M^{-1}&=&\left(\begin{array}{cc}
1&-1\\
-1&2\end{array}\right),\\
M^{-1}K&=&\left(\begin{array}{cc}
2&-1\\
-2&2\end{array}\right)\omega_0^2.
\end{eqnarray*}
$$
<p>&nbsp;<br>

<p>
One can find a transformation, basically a rotation, that transforms
to a frame where \( M^{-1}K \) is diagonal. In this coordinate system the
diagonal components of \( M^{-1}K \) represent the squared frequencies of
the normal modes,

<p>&nbsp;<br>
$$
M^{-1}K\rightarrow -\left(\begin{array}{cc}
\omega_+^2&0\\
0&\omega_-^2\end{array}\right),
$$
<p>&nbsp;<br>

<p>
and are known as &quot;eigen&quot; frequencies. The corresponding unit vectors,

<p>&nbsp;<br>
$$
\left(\begin{array}{c}
1\\0\end{array}\right)茯犷潺莒彐舁茆彗轭狎蜥泯败鼙苠钿狎蜥茯殓梏茯轭翳妣铄齄泔矧溟钺翦簌篝屙い拣睛钼箴患怛拣汜忮蝻翎翦忉汶轭麸翳矧殓轭犰骝犴瀣犷忮泔礤翳箫祯糸镱骘翳铒蝽犰盹溴螽澡弩狎翳孱汜祆邃聃雉诲殓孱鲥泗矧螃聃雉滑麒殂狎翳筢礤狍翳铒蝽犰盹溴螽崎钿轭翳彘珏铈蝈聃孱汩弩轶疱蜴矧礤怡蝈犰辁轭翳狒翳溴翦蝽轭犷镦磲趄轼轶躅汨犷珏怡翳蝻翎糸镱忮赭邋泔矧溟钺翦簌篝屙螽昨轸轭翳羼踽糸镱镦盹糸镱狍犷彘珏铞犰蹂痱镡戾憩拣睛钼箴患怛い茆彗轭羼钺蝌狴莒彐糅镰莒犴怃徇檐磲翳忖饼茯殓梏蒗唛溅艾淋羼蹰娃饼爽莒犴怃徇檐羼蹰茱礤玑薏唛苠钿羼钺蝌狴い拣睛钼箴患怛拣深翳泔矧溟钺翦簌篝屙麒弪塄娃饼堠轶溟徵镱犰犷翳骘蝽骘塄踹堠狎箝眇戾翳轶蝈聃轵弩翳狒轭翳狒簌篝屙翳溟徵镱犰屐屙孱趔镦塄娃饼堠狎翳彘珏铞犰蹂蟋塄茱礤玑唛薏堠骑遽汨塄茱礤玑薏唛堠翳溴翦蝽轭犷塄镰莒犴怃徇檐磲翳忖饼堠眭篝鲠铋箬澡轶轶翳孱趄蹂轭犷泔矧溟钺翦簌篝屙拣睛钼箴患怛い茆彗轭羼钺蝌狴茯溴酏莒彐糅镰莒犴怃彳磲翳忖饼茯殓梏荭溅艾苠钿羼钺蝌狴い拣睛钼箴患怛拣麒殂骘塄曹糸礤堠磲趄轼忮泔礤拣睛钼箴患怛い茆彗轭羼钺蝌狴莒彐酎茆彗轭狎蜥沣吝北莒犴怃幡吝辈苘吝脖α啕膊莒犴怃苠钿狎蜥茯殓梏溅艾苘吝北吝膊莒犴怃吝北莒犴怃吝膊莒犴怃徂箔吝脖吝辈溅爱苠钿羼钺蝌狴い拣睛钼箴患怛拣项汜箫祧聃徜蜥糸羼踽糸镱骘塄莒犴怃堠麒殂玳鲥赭彘珏铞犰蹂泔蝌弩痫钿轭麸塄茱礤玑攉薏堠犷塄茱礤玑攮薏堠骘躅徕秭瀹描镲箝铉镱镦翳彘珏铞犰蹂蟋镱汜轭箦螋镱镦翳彘珏铞犰蹂塄莒犴怃徇堠轭麸翳彘珏铞犰蹂痱镡戾犷箫祧骘塄踹堠翳孱汨镲箦翳雉桢彘珏铞犰蹂犷箫祧骘翳雉桢泔蝌弩痫钿轭鲥泗矧拣涉翳轶麇蝈抄溟礤铙轱钺箦镦羼踽糸镱蟋翳溴翦蝽轭犷黠蹯轭沆蹁翦蝽扉脲塄莒犴怃徂堠犷黠蹯忮泔礤沲忾羼踽糸镱鏖翳翳蝈彘珏铞犰蹂螽项黠蹯翳孱箫祧骘翳蝈彘珏铞邈麸蝮涉镱栳簌篝屙鏖翳溟礤铙轱钺扉豉塄罹堠镱躞踽祆蝈箫螋麸箫祧轭翳痱镡戾铛礤蜷汜祆漉麸翳礤篌轭弩镦翳犰珏怛岙澡磲轭痱镧蜥眄轭灬铉踽珏犰栳鲥疳汶徵弩麒殂蝈徜殪溟徵镱犰辁磲趄殂弩犷骈钿彘珏铞邈麸蝮犷彘珏铞犰蹂螽艰殇舰泔铙弪鲠糸镱灬黧⒕蔑铙弪鲠糸镱提黧集璨拣蓬弪琦轶泔铙弪鲥镱禊麒孱翳提珧犷玳犷栳铒屮痨殂轸溴疱钿孱沐镱糸礤楫瀹塄台瘳茕雉颀堠铒塄台瘳茕雉颀舂堠燥箬秣翳轶麇骈蝮溴骈铄翳柔黹祠镱獒瞵拣睛钼箴患怛い茆彗轭羼钺蝌狴圈溅荏蹴唛莒彐舁茕雉颀唛苕蜥沱莛狎糸犰听莛狎糸犰茕雉颀唛茯殓梏┉坍苠钿羼钺蝌狴い拣睛钼箴患怛拣伶翦箬秣轭翳狒塄堠轶泔铙弪鲥洮楫瀹塄ㄤ漪┤桨堠麇翳孱箬秣翳狒塄堠汜忮殇孱糸骈邃鏖翳翳麸翎孱弪琦塄冉垣堠拣项汜箦翳狒塄堠轶泔铙弪鲥怡狃痨轭骈蝮躞轭翳汨衢蝓戾骘塄ㄤ漪┤堠翳孱狃痨轭提珧犷珏羼踽糸镱蟋拣睛钼箴患怛い茆彗轭羼钺蝌狴苕蜥沱潺漪圈溅荏蹴唛莒彐糗茕滹酐颀唛苕蜥沱莛狎糸犰听莛狎糸犰茕雉颀唛茕雉颀唛苕蜥沱潺漪莒彐舁苕蜥沱莛狎糸犰听莛狎糸犰茕雉颀唛茯殓梏┉苕蜥沱莛狎糸犰听莛狎糸犰茕雉颀唛茕滹酐颀唛苕蜥沱莛狎糸犰听莛狎糸犰襁辇茕雉颀唛茯殓梏荦苘茴镱蹴忮溅荏蹴唛莒彐糗茕滹酐颀唛苕蜥沱莛狎糸犰听莛狎糸犰茕雉颀唛茕雉颀唛苕蜥沱莛狎糸犰听莛狎糸犰襁辇苕蜥沱莛狎糸犰听莛狎糸犰茕雉颀唛茕滹酐颀唛苕蜥沱莛狎糸犰听莛狎糸犰襁辇茕雉颀唛茯殓梏荦苘茴镱蹴忮溅爱苠钿羼钺蝌狴い拣睛钼箴患怛拣澡弩篝屦狍篚礤翳狒塄堠栳铒屮痨殂轸糸礤溴疱钿孱沐楫瀹塄堠轶骢钽糸镱镦塄堠犷塄茕雉颀堠怩铒镦塄堠拣五衄麇箬秣翳狒塄堠汜忮殇孱糸骈邃鏖翳翳孱弪琦洛汜躞塄堠滹弩铒溴疱钿镱塄茕雉颀堠拣睛钼箴患怛い茆彗轭羼踽糸镱冉荏蹴唛苕蜥沱莛狎糸犰札莛狎糸犰茕雉颀唛茕雉颀唛垣之荇徵卑苠钿羼踽糸镱い拣睛钼箴患怛拣涉翳腴铄糸孱弪琦栳瘐蝈禊聃徜蜥糸骘蝽轭翦蝽镦塄茕雉颀堠拣睛钼箴患怛い茆彗轭羼踽糸镱越荏蹴啕殛吝殛瘵茕雉颀唛茕雉颀哧荇徵北苠钿羼踽糸镱い拣睛钼箴患怛拣翳柔黹祠镱獒忮泔礤拣睛钼箴患怛い茆彗轭羼钺蝌狴圈溅荏蹴啕殛擦啕殛瘵茕雉颀唛茕雉颀哧荏蹴啕殛吝殛瘵茕雉颀唛茕雉颀哧周茴镱蹴忮溅垣之苠钿羼钺蝌狴い拣睛钼箴患怛拣澡痱镲翳狒塄堠羼踽祗翳孱弪琦栝铉邃镱翳驷泗翳狒翳腴铄糸孱弪琦麽聃徜蜥糸轭塄茕雉颀堠澡轶汜忮狒趄殁豸邃麸糸礤蝈鲥蝮犰簌眄弭蝙洛汜躞翳冕螋弩獒泔矧溟钺翦塄唛堠滹铒溴疱钿镱塄茕雉颀唛堠矧镱糸礤塄茕雉唛建莛狎糸犰唛莛狎糸犰襁戛茕雉颀哧堠澡躞翳腴铄糸孱弪琦塄越碥滹酐唛薏堠箬秕熹忮痱镳矧糸镱犰麸赭痫麇蝮镦塄茕雉颀堠麒殂鲠扉溽翦翳狍篚眇糸镱徕秭瀹拣儒蝈孱弪琦泔铙弪鲠糸镱轶痱邃殂狒邃镱翳提珧犷玳犷铒栳鲩铉犷屮痨殂轸糸礤溴疱钿孱沐组翳秕犷屮痨殂轸糸礤溴疱钿孱沐翳羼踽糸镱镦盹糸镱狎躅汨犷珏殒镱趄犷箪狒弩骈邃犴秕铘轭糸礤忮汜躞翳痂箝泱滹弩铒溴疱钿镱麒孱翳沆镢篝狎趔深泔铘蜥篝翳徕箫祯翦糸礤忮泔礤蝈戾鲠铘殒翳弪轶犷屮痨殂轸糸礤溴疱钿孱沐深驷泗泔铙弪鲠糸镱灬黧汜躞踽祆忮狍箫汩狒邃鏖翳簌眄弭蜷弩深翳轶汜箦翳趄犷箪狒轱簌眄弭蝙轭糸礤戾徜麸孱弪琦泔铙弪鲠糸镱拣骑犷雉桢屮犴痨镦栾簌眄弭蝙戾徜麸泔铙弪鲠糸镱灬黧泔铙殇弪提珧犷玳犷骘疳螋殂戾镦磲篌塄堠盹鲩铉轭赭锃溟礤铙轱钺痨犷麒弪翳珏铄蜥扉邃泔矧溟钺翦狎翳蜥溟躞塄堠犷翳犷珈塄荇桢翎堠澡腴铄糸孱弪琦黠蹯忮拣睛钼箴患怛い茆彗轭羼踽糸镱越苕蜥沱饼昌碥戾骠茺茕雉螨薏蜣曹滹酐荇桢翎薏茯殓梏荦荇徵辈苠钿羼踽糸镱い拣睛钼箴患怛拣犷殒翳痫翦铘獒孱弪琦塄吱颟堠溴疱钿镱禊镱翳蜥溟躞塄堠犷铒镱翳犷珈瀣提珧犷珏羼踽糸镱忮泔礤拣睛钼箴患怛い茆彗轭羼钺蝌狴苕蜥沱潺漪碥滹酐螨│溅苕蜥沱莛狎糸犰铸莛狎糸犰螨碥滹酐荇桢翎薏颥苘茴镱蹴忮苕蜥沱潺漪眚薏茕雉荇桢翎│溅爱苠钿羼钺蝌狴い拣睛钼箴患怛拣澡箦泔钿羼踽糸镱轫痨殄翳狒塄眚薏茕雉荇桢翎堠轶泔铙翎铘深溴邃轸轶翳犷珲灬盹礤铘蹴麒殂轶泔铙弪鲥骘蜥溟犰骘蜚瀹儒蝈翳泔铙弪鲠糸镱镦犷珲灬盹礤铘蹴轶狍箫汩狒邃鏖翳翳轭溴疱钿孱沐镦翳痂箝泱麸汨犷珏轭塄荇桢翎堠矧轭雉桢黠蜾蟋蝻翎糸镱犰轭鲠蜷犷沐项沐镱腩秣翳驷泗翳狒塄探眚薏茕雉荇桢翎堠轶泔铙弪鲥洮轸汜忮轭箦螋邃轭麸翳羼踽糸镱镦盹糸镱骘塄茕雉螨堠拣睛钼箴患怛い茆彗轭羼踽糸镱碥滗雉螨江苕蜥沱莛狎糸犰铸莛狎糸犰螨苕蜥沱剔昌眚蕹荇徵背苠钿羼踽糸镱い拣睛钼箴患怛拣澡轶轶蝈灬翦麸坚栩彐舰梏麴函孱鏖腴疱溟岙矧绡鏖腴物弭桢颛筮翳屣蝈恝翎蜱弭舰哜灬铍⒕彭睐物弭桢颛翳屣蝈砑峋拣娱眇禊篝狒邃殒翳提珧犷玳犷塄堠轶轭溴疱钿孱镦塄襁堠镱汜箦翳狒翳聃犷糸豉塄莛狎糸犰摊莛狎糸犰茕雉颀唛堠轶泔铙弪鲥洮拣睛钼箴患怛い茆彗轭羼踽糸镱苕蜥沱潺漪苕蜥沱莛狎糸犰听莛狎糸犰茕雉颀唛桨荇徵贝苠钿羼踽糸镱い拣睛钼箴患怛拣令雉桢遽簌屮犴痨轶轭冕螋弩獒泔矧溟钺翦麒弪翳痫翦铘獒溴疱钿镱禊镱塄堠犷塄堠怩铒镱塄堠深翳狒汜箦翳弪轶趄犷箪狒轱钺簌眄弭蝙乞镯翳灬篝羼踽糸镱翳轶趄犷箪狒弩轭麸泔铙弪鲠糸镱镦翳盹礤铘蹴轭翳塄堠溟蝈泗轱町拣蔑铙殇弪疳轵镦疳螋殂戾镦磲篌塄磉堠犷塄磉堠麒弪翳痫翦铘獒轶镦翳骘蝽拣睛钼箴患怛い炸茆镬潴礅镬螨弑茆镬潴礅镬螨卟┙诌屺磉避怙熹簌礅镬螨弑磉曹怙熹簌礅镬螨卟磉鲍磉博┇诌猕茆镬潴礅镬螨弑茆镬潴礅镬螨卟┊い拣睛钼箴患怛拣阵轭簌眄弭蝙狎珲礤铘犰镱瀣狎翳弪犷泔铙弪鲥泔眇镱孱趔镦翳盹礤铘蹴矧翳犷珲灬盹礤铘蹴靠拣澡弪轶铒趄犷箪狒轱钺轭鲠蜷犷沐桢钽翳弪狎铒泔铙弪鲥泔眇镱孱趔镦翳盹礤铘蹴蕊麇鲥颥翳弪轶蝻翎糸镱犰轭鲠蜷犷沐徕秕犷狲轶翳狒顼弩翳蝻蹒翳矧殓轭儒钽瀣翳弪轶犷珲灬盹礤铘蹴泔铙弪鲠糸镱轭犰翳蝈溟蝈泗轱铙御眄弭蝙狎珲礤铘狎珧遽麽麸蝈泔珙辁翳屮轶翦钽镦泔铙弪鲥聃犷糸糸弩怩徙趱犰禊屮痱弩箝铉翳屙轭翦蝽镦泔矧溟钺翦汜忮趄殂膣骑轭篝犷沐秕磲铄邃麸黩轸翳提珧犷玳犷轭翦蝽镦犷珈弩拣肌盹蝈屮犴痨弩麸忮徜溴洮轭疳螋殂蹯狎溴鲥祜忮趑弪疱钿蹯蹴盹溴鏖翳泔铙趄衢铘肌龄磲翦蜷犰徕秕犷珲灬盹礤铘蹴泔铙弪鲠糸镱犷扉铄狎盹礤铘蹴肌龄磲翦蜷犰徕秕铒瞽轭弪糸犰骝犴弩肌娘踱戾疱钿蹯蹴犷骑蹉犰臾疱钿蹯蹴肌义鲩箝矬汩祆狒轱铙犷屮犴痨镱遽螋桉踽脲盹溴祗集箦泗轱罹集溟鼍肌沆狍蠼Ⅲ扉溴螈集溟鼍肌沆狍蠼Ⅱ弼遽膦俭泸轲篁憬Ⅱ弼遽飚牦扉獐牦桢徜黹町牦⒕集筱蜷痿俭泸轲篁憬Ⅱ弼遽飚牦牦蝈鲥犰牦⒕集筱蜷痿俭泸轲艟契祆扉篝镦泔铈殓躜狒轱镳糸镱狯衢灬忪桢蝈梏麴蠛玳翳踱泔懑栳腴礤殳蝈鲥犰牦ｃ镱骈珲蜥糸镱义鲥犰轭轸獒扉濞拈箴灬钺鲩玑糸镱泔铘蝻祗轭翳怙趑镯蜷玷泔蝾弪泔铘蝻祗趄蹂拈箴灬痱镧蝈篌忉ㄢ屐秣翳栾蜷箪殇弪痱镧蝈篌趄蹂拈箴灬翳疳珏铛礅弪镦翳沲蝌孱箪殇箪殇逦蹴忮蚝趄蹂絮箬遽汨箪殇汨犷珏麸翳怛秣箦栝篝矧栝篝矧驷祗瀣蓬徕戾脲怙狎箬矧翥豸骘钺鲩玑糸镱脲怙狎浜趄蹂蓬徕戾翳箪殇秭弪鲩鬻盹溴秭弪鲩鬻趄蹂皱螋殂犰沐铘弪轭镦箪殇弩沐铘弪趄蹂沐铘弪驷祗瀣蓬徕戾麸蹉钺鲩玑糸镱镱溴鲩沐鏖翳麸蹉轭瘐麸蹉韬趄蹂田镳翳痱弩孱翎糸镱祜镳驷祗瀣描犷珏翳痱弩孱翎糸镱溟蝈泗轱麸忮以螋旌驷祗瀣怎蝾骝徵礤铘镱犷镦珈镡犰禊骝徵礤铘蠛趄蹂旗徵殒翳痱弩孱翎糸镱轶蝓铑轭轭犷屙忮滗邃盹溴楫瀹泔铘衢铄鏖翳轭扉黹翦痫螋轱镦翳筱蝈孱屙忮滗邃驷祗瀣熙礅弪镦黹祆轶邈镱潴忮赭邋狨麸磲糸汜祆痱镢邋溟铉麸翳铄箪殇瀣溟筢忪邃麒孱箦麸艾翳轶鲠祯汜忮秭弪黩轸翦怡躞轭溽翎狨麸箪殇狒趄殁豸镱秕箪殇弩狨麸屿殇搴艾郁镳狨麸箪殇轭徭翦躞弪轭瘐狨麸屿殇逵麸痧徕戾趄蹂蓬徕戾箪殇钺鲩玑糸镱鲩盹躞麒邋盹躞遄桢屐驷祗瀣乳溴翳徜潋弩忉镱盹忾戾溴鲩沐栝溴龄潋弩舐狎趄蹂橡孱扉铍轭犷殒蜥礤痱弼殄秭弪灬痱弼殄魈轭塍驷祗瀣则犷箝糸镱篝戾趄犷箝糸镱т彐狨祠К溴驷蹯舣沲忮疳珏泔钽狯瀵镲懑扉铄狎驷溴铒铄则犷箝糸镱箴邋趄犷箝糸镱羽邋浜т彐狨祠К溴驷蹯舣驷篝箪秣则犷箝糸镱篝戾骘骢祆疳珏箪殇忉汶珧秕钿忉汶珧秕钿则犷箝糸镱т彐狨祠К溴驷蹯舣铒铄箪殇瀵泔钽狯瀵泔铞屮镲熙礅弪镦箪殇弩狩狴骝镯翳沲蝌孱翳狒狎鲩箝忪鲩鬻拈篝犷沐超嗅蜥祆狲忉汶珧秕钿轫徵疳蜥祆狲箩汶珧秕钿身徵搴Ё瀹绠ц趑痼函蟪犴狷镱狩螽泔懑栳腴憝篝狒殂蝈鲥犰牦蝈鲥犰疳蜥祆狲碑牮绉嗅蜥祆狲忉汶珧秕钿箝疳蜥祆狲箩汶珧秕钿娱搴Ё糜簌铘狲瀹绠⒉卑梆拱梆翳屙搴义鲥犰珏粞蹂蝙柔箬ī翳屙瀣狯衢灬忪翳屙弩狎轭蝈鲥犰牦泱蟑翳屙趄犷箝糸镱义鲥犰珏粞蹂蝙柔箬ī趄犷箝糸镱т彐狨祠К溴驷蹯舣沲忮疳珏泔钽狯瀵镲懑扉铄狎铒铄┗义鲥犰轭轸獒扉濞溴疱钿孱汩弩抿矬蟓怛秣箦箬轫翳狒骢祆轫痨屙孱趔沆狍筇轶梏麴蠛玳翳踱泔懑屐殓蝈沆狍筇轶舢牦篁愫蝈鲥犰牦扉獐牦沆狍筇轶舢牦К泔钿轸轱詈骢钽糸镱ī蝈趱蝾′镢蹴孱舢怙澌沆狍筇轶艋深翦蝠蝈歪螂滹黝轭俭邈糸镱屐屙孱趔篁愫蝈鲥犰牦痨蹒轭磲螂滹黝磲螂邃牦К泔钿轸轱詈骢钽糸镱ī蝈趱蝾　滹沲礤铘聃弪渝戾泗矧й溽翎磲螂滹黝荮┗篁愫蝈鲥犰牦痨蹒轭磲螂滹黝磲螂滹黝牦К泔钿轸轱詈骢钽糸镱ī蝈趱蝾　滹沲礤铘聃弪渝戾泗矧й溽翎磲螂滹黝荮┗御铘狲栝玷扉玷骘笺镤寰屐屙孱趔篁愫蝈鲥犰牦痨蹒轭栝玷扉玷舣栝玷扉玷舢牦К狍钽趄蹂汜祆忉汶骢钽糸镱ī桁牦轭轸乳玷扉玷糸铉项田徜ī陲镯轭犷秕鏖翳领臬沆殂篁愫蝈鲥犰牦痨蹒轭镲憝牦镲懋牦К狍钽趄蹂泔钿轸轱詈骢钽糸镱ī蝈趱蝾　滹沲礤铘怙澌沆狍筇轶艋羽遽脲铒翦篁愫蝈鲥犰牦痨蹒轭铒翦蟑铒翦螽牦К狍钽趄蹂泔钿轸轱詈骢钽糸镱ī蝈趱蝾　滹沲礤铘怙澌沆狍筇轶艋义盹翦泔铘蝻秕蝈鲥犰牦痱弩孱翎糸镱躞轭麸蹉溴鲩沐篁愫蝈鲥犰牦痨蹒轭蝈盹翦蟑蝈盹翦螽牦К狍钽趄蹂泔钿轸轱詈骢钽糸镱ī蝈趱蝾　滹沲礤铘怙澌沆狍筇轶艋歪翳梳篁愫蝈鲥犰牦痨蹒轭磲翳磲翳牦К狍钽趄蹂┗义鲥犰轭轸獒扉濞澡㈩矧磲膦箝镦翳痱弩孱翎糸镱狍疱泗蜥糸鏖祆忮痱弩弪鲥麒孱翳痱弩孱翎糸镱轶筱犰邃麸骈溟骀弪孱蝈箫祯糸镱螽冕忮箴邈殒殄躞轭疱蜚孱翎珏躅轸螽鏖漪韬北钒矧殓轭犰苟艾桢殓梏钒艾漆泗矧镦翳溟箴灬箝翳狒箬秕熹蝈磲轭屙痿狎秕钿翳泔铘孱磲蜱轭爱爆嘛躅潴骘箜犰戾篝灬蜱弩痫篌殁戾筱犰麸狃痨麸泔铘孱黹钣汜戾爱铂磲鱼犰搴碑┗集筱蜷痿肌忮玳骘雉弪祜顼间轹篝戾舰痫箝糸镱徕箫祯翦怙趑镯梆戾骠盎磲蜱轭戾骠梆⒕奸礴篁憬Ⅲ镯屐镧锂痤纰集溟鼍孱骘雉弪祜顼集怙澌集梏盱
<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week13.do.txt --pygments_html_style=perldoc --html_style=solarized3 --html_links_in_new_window --html_output=week13-solarized --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="PHY321: Two-body problems, gravitational forces and discussion of second midterm">
<title>PHY321: Two-body problems, gravitational forces and discussion of second midterm</title>
<link href="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<link href="https://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Aims and Overarching Motivation',
               2,
               None,
               'aims-and-overarching-motivation'),
              ('Monday April 3', 3, None, 'monday-april-3'),
              ('Wednesday April 5', 3, None, 'wednesday-april-5'),
              ('Friday April 7', 3, None, 'friday-april-7'),
              ('Code example with gravitional force',
               3,
               None,
               'code-example-with-gravitional-force'),
              ('Plotting the potential first',
               2,
               None,
               'plotting-the-potential-first'),
              ('Solving the differential equations, Radial Degrees of Freedom '
               'only',
               2,
               None,
               'solving-the-differential-equations-radial-degrees-of-freedom-only'),
              ('Changing initial conditions',
               2,
               None,
               'changing-initial-conditions'),
              ('Different Potential', 2, None, 'different-potential'),
              ('Plotting the Effective Potential',
               2,
               None,
               'plotting-the-effective-potential'),
              ('Finding the Minimum for Circular Orbits',
               2,
               None,
               'finding-the-minimum-for-circular-orbits'),
              ('Numerical Studies', 2, None, 'numerical-studies')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- ------------------- main content ---------------------- -->
<center>
<h1>PHY321: Two-body problems, gravitational forces and discussion of second midterm</h1>
</center>  <!-- document title -->

<!-- author(s): <a href="http://mhjgit.github.io/info" target="_blank">Morten Hjorth-Jensen</a> -->
<center>
<b><a href="http://mhjgit.github.io/info" target="_blank">Morten Hjorth-Jensen</a></b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics and Astronomy and Facility for Rare Isotope Beams (FRIB), Michigan State University, USA</b>
</center>
<center>
[2] <b>Department of Physics, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>April 3-7</h4>
</center> <!-- date -->
<br>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="aims-and-overarching-motivation">Aims and Overarching Motivation </h2>
<h3 id="monday-april-3">Monday April 3 </h3>

<ol>
<li> Physical interpretation of various orbit types and summary gravitational forces</li>
<li> Second midterm available Monday April 3, deadline April 16 at midnight.</li>
<ul>
  <li> <a href="https://youtu.be" target="_blank">Video of lecture TBA</a></li>
  <li> <a href="https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/Spring2022/NotesApril4.pdf" target="_blank">Handwritten notes</a></li>
</ul>
</ol>
<p>Look up for example the README file at <a href="https://github.com/mhjensen/Physics321/blob/master/README.md" target="_blank"><tt>https://github.com/mhjensen/Physics321/blob/master/README.md</tt></a> for an update on solutions to various assignments.</p>

<p><b>Reading suggestion</b>: Taylor chapter 8 and Lecture notes as well handwritten notes from this Monday. These notes are also relevant for the second midterm and later also (after the deadline for the second midterm) homework 9.</p>
<h3 id="wednesday-april-5">Wednesday April 5 </h3>

<ol>
<li> Discussion of second midterm, hints and tips and Kepler orbit analysis</li>
<ul>
  <li> <a href="https://youtu.be/" target="_blank">Video of Lecture TBA</a></li>
  <li> <a href="https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/Spring2022/NotesApril6.pdf" target="_blank">Handwritten notes</a></li>  
</ul>
</ol>
<p><b>Reading suggestion</b>: Taylor chapter 8 and lecture notes</p>
<h3 id="friday-april-7">Friday April 7 </h3>

<ol>
<li> Work on second midterm, hints and tips</li>
<ul>
  <li> <a href="https://youtu.be/" target="_blank">Hints and tips for second midterm, video of lecture TBA</a></li>
  <li> <a href="https://github.com/mhjensen/Physics321/blob/master/doc/HandWrittenNotes/Spring2022/NotesApril8.pdf" target="_blank">Handwritten notes</a></li>
</ul>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h3 id="code-example-with-gravitional-force">Code example with gravitional force </h3>

<p>The code example here is meant to illustrate how we can make a plot of
the final orbit. We solve the equations in polar coordinates (the
example here uses the minimum of the potential as initial value) and
then we transform back to cartesian coordinates and plot \( x \) versus
\( y \). We see that we get a perfect circle when we place ourselves at
the minimum of the potential energy, as expected.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="plotting-the-potential-first">Plotting the potential first </h2>

<p>The code here plots the effective potential</p>

<p>The following code plots this effective potential for a simple choice of parameters, with a standard gravitational potential \( -\alpha/r \). Here we have chosen \( L=m=\alpha=1 \). </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

Deltax = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays</span>
xinitial = <span style="color: #B452CD">0.3</span>
xfinal = <span style="color: #B452CD">5.0</span>
alpha = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># spring constant</span>
m = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># mass, you can change these</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
n = ceil((xfinal-xinitial)/Deltax)
x = np.zeros(n)
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
    x[i] = xinitial+i*Deltax
V = np.zeros(n)
V = -alpha/x+<span style="color: #B452CD">0.5</span>*AngMom*AngMom/(m*x*x)
<span style="color: #228B22"># Plot potential</span>
fig, ax = plt.subplots()
ax.set_xlabel(<span style="color: #CD5555">&#39;r[m]&#39;</span>)
ax.set_ylabel(<span style="color: #CD5555">&#39;V[J]&#39;</span>)
ax.plot(x, V)
fig.tight_layout()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="solving-the-differential-equations-radial-degrees-of-freedom-only">Solving the differential equations, Radial Degrees of Freedom only  </h2>

<p>This code and the subsequent one are relevant for homework 9 (the numerical exercise).</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Simple Gravitational Force   -alpha/r</span>
<span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #228B22"># Where to save the figures and data files</span>
PROJECT_ROOT_DIR = <span style="color: #CD5555">&quot;Results&quot;</span>
FIGURE_ID = <span style="color: #CD5555">&quot;Results/FigureFiles&quot;</span>
DATA_ID = <span style="color: #CD5555">&quot;DataFiles/&quot;</span>

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(PROJECT_ROOT_DIR):
    os.mkdir(PROJECT_ROOT_DIR)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(FIGURE_ID):
    os.makedirs(FIGURE_ID)

<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(DATA_ID):
    os.makedirs(DATA_ID)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">image_path</span>(fig_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(FIGURE_ID, fig_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">data_path</span>(dat_id):
    <span style="color: #8B008B; font-weight: bold">return</span> os.path.join(DATA_ID, dat_id)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">save_fig</span>(fig_id):
    plt.savefig(image_path(fig_id) + <span style="color: #CD5555">&quot;.png&quot;</span>, <span style="color: #658b00">format</span>=<span style="color: #CD5555">&#39;png&#39;</span>)


    
DeltaT = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">8.0</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v and r</span>
t = np.zeros(n)
v = np.zeros(n)
r = np.zeros(n)
phi = np.zeros(n)
x = np.zeros(n)
y = np.zeros(n)
<span style="color: #228B22"># Constants of the model, setting all variables to one for simplicity</span>
alpha = <span style="color: #B452CD">1.0</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
m = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22"># scale mass to one</span>
c1 = AngMom*AngMom/(m*m)
c2 = AngMom*AngMom/m
rmin = (AngMom*AngMom/m/alpha)
<span style="color: #228B22"># Initial conditions, place yourself at the potential min</span>
r0 = rmin
v0 = <span style="color: #B452CD">0.0</span>  <span style="color: #228B22"># starts at rest</span>
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
phi[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.0</span>
<span style="color: #228B22"># Start integrating using the Velocity-Verlet  method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up acceleration</span>
    a = -alpha/(r[i]**<span style="color: #B452CD">2</span>)+c1/(r[i]**<span style="color: #B452CD">3</span>)
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*(DeltaT**<span style="color: #B452CD">2</span>)*a
    anew = -alpha/(r[i+<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)+c1/(r[i+<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
    phi[i+<span style="color: #B452CD">1</span>] = t[i+<span style="color: #B452CD">1</span>]*c2/(r0**<span style="color: #B452CD">2</span>)
<span style="color: #228B22"># Find cartesian coordinates for easy plot    </span>
x = r*np.cos(phi)
y = r*np.sin(phi)
fig, ax = plt.subplots(<span style="color: #B452CD">3</span>,<span style="color: #B452CD">1</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;radius&#39;</span>)
ax[<span style="color: #B452CD">0</span>].plot(t,r)
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_ylabel(<span style="color: #CD5555">&#39;Angle $\cos{\phi}$&#39;</span>)
ax[<span style="color: #B452CD">1</span>].plot(t,np.cos(phi))
ax[<span style="color: #B452CD">2</span>].set_ylabel(<span style="color: #CD5555">&#39;y&#39;</span>)
ax[<span style="color: #B452CD">2</span>].set_xlabel(<span style="color: #CD5555">&#39;x&#39;</span>)
ax[<span style="color: #B452CD">2</span>].plot(x,y)

save_fig(<span style="color: #CD5555">&quot;Phasespace&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="changing-initial-conditions">Changing initial conditions </h2>

<p>Try to change the initial value for \( r \) and see what kind of orbits you get.
In order to test different energies, it can be useful to look at the plot of the effective potential discussed above.
</p>

<p>However, for orbits different from a circle the above code would need modifications in order to allow us to display say an ellipse. For the latter, it is much easier to run our code in cartesian coordinates, as done here. In this code we test also energy conservation and see that it is conserved to numerical precision. The code here is a simple extension of the code we developed for homework 5.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">pandas</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">pd</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

DeltaT = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">10.0</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays</span>
t = np.zeros(n)
v = np.zeros((n,<span style="color: #B452CD">2</span>))
r = np.zeros((n,<span style="color: #B452CD">2</span>))
E = np.zeros(n)
<span style="color: #228B22"># Constants of the model</span>
m = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># mass, you can change these</span>
alpha = <span style="color: #B452CD">1.0</span>
<span style="color: #228B22"># Initial conditions as compact 2-dimensional arrays</span>
x0 = <span style="color: #B452CD">0.5</span>; y0= <span style="color: #B452CD">0.</span>
r0 = np.array([x0,y0]) 
v0 = np.array([<span style="color: #B452CD">0.0</span>,<span style="color: #B452CD">1.0</span>])
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
rabs = sqrt(<span style="color: #658b00">sum</span>(r[<span style="color: #B452CD">0</span>]*r[<span style="color: #B452CD">0</span>]))
E[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.5</span>*m*(v[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>]**<span style="color: #B452CD">2</span>+v[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)-alpha/rabs
<span style="color: #228B22"># Start integrating using the Velocity-Verlet  method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up the acceleration</span>
    rabs = sqrt(<span style="color: #658b00">sum</span>(r[i]*r[i]))
    a =  -alpha*r[i]/(rabs**<span style="color: #B452CD">3</span>)
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*(DeltaT**<span style="color: #B452CD">2</span>)*a
    rabs = sqrt(<span style="color: #658b00">sum</span>(r[i+<span style="color: #B452CD">1</span>]*r[i+<span style="color: #B452CD">1</span>]))
    anew = -alpha*r[i+<span style="color: #B452CD">1</span>]/(rabs**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
    E[i+<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0.5</span>*m*(v[i+<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>]**<span style="color: #B452CD">2</span>+v[i+<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>)-alpha/rabs
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
<span style="color: #228B22"># Plot position as function of time</span>
fig, ax = plt.subplots(<span style="color: #B452CD">3</span>,<span style="color: #B452CD">1</span>)
ax[<span style="color: #B452CD">0</span>].set_ylabel(<span style="color: #CD5555">&#39;y&#39;</span>)
ax[<span style="color: #B452CD">0</span>].set_xlabel(<span style="color: #CD5555">&#39;x&#39;</span>)
ax[<span style="color: #B452CD">0</span>].plot(r[:,<span style="color: #B452CD">0</span>],r[:,<span style="color: #B452CD">1</span>])
ax[<span style="color: #B452CD">1</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">1</span>].set_ylabel(<span style="color: #CD5555">&#39;y position&#39;</span>)
ax[<span style="color: #B452CD">1</span>].plot(t,r[:,<span style="color: #B452CD">0</span>])
ax[<span style="color: #B452CD">2</span>].set_xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
ax[<span style="color: #B452CD">2</span>].set_ylabel(<span style="color: #CD5555">&#39;y position&#39;</span>)
ax[<span style="color: #B452CD">2</span>].plot(t,r[:,<span style="color: #B452CD">1</span>])

fig.tight_layout()
save_fig(<span style="color: #CD5555">&quot;2DimGravity&quot;</span>)
plt.show()
<span style="color: #658b00">print</span>(E)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="different-potential">Different Potential </h2>

<p>Let us now try another potential, given by</p>
$$
V(r) = \beta r,
$$

<p>where \( \beta \) is constant we assume is larger than zero. This type of potential has played an importan role in modeling confinement of quarks in non-relativistic models for the interactions among quarks, see for example <a href="https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.44.1369" target="_blank"><tt>https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.44.1369</tt></a> </p>

<p>Adding the angular momentum part, we obtain the effective potential</p>

$$
V_{\mathrm{eff}}(r) = \beta r+\frac{L^2}{2\mu r^2},
$$

<p>and taking the derivative with respect to \( r \), we get the radial force</p>

$$
F_r=-\frac{dV_{\mathrm{eff}}(r)}{dr} = -\beta+\frac{L^2}{\mu r^3}.
$$

<p>It gives us in turn a radial acceleration \( a_r \)</p>
$$
a_r= -\frac{\beta}{\mu}+\frac{L^2}{\mu^2 r^3}.
$$

<p>This is the equation we need to include in our code. I have not been able to find out if there is an analytical solution to the above equation. If you can find one, there is a reward of \( 50 \) USD to the first one who finds. Numerically life is very easy, we just define a new acceleration, as seen below.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="plotting-the-effective-potential">Plotting the Effective Potential </h2>

<p>First however, we plot the effective potential in order to get a feeling of what we may expect.</p>

<p>The following code plots this effective potential for a simple choice of parameters, with a potential \( \beta r  \). Here we have chosen \( L=m=\beta=1 \). </p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Common imports</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

Deltax = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays</span>
xinitial = <span style="color: #B452CD">0.3</span>
xfinal = <span style="color: #B452CD">5.0</span>
beta = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># spring constant</span>
m = <span style="color: #B452CD">1.0</span>   <span style="color: #228B22"># mass, you can change these</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
n = ceil((xfinal-xinitial)/Deltax)
x = np.zeros(n)
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
    x[i] = xinitial+i*Deltax
V = np.zeros(n)
V = beta*x+<span style="color: #B452CD">0.5</span>*AngMom*AngMom/(m*x*x)
<span style="color: #228B22"># Plot potential</span>
fig, ax = plt.subplots()
ax.set_xlabel(<span style="color: #CD5555">&#39;r[m]&#39;</span>)
ax.set_ylabel(<span style="color: #CD5555">&#39;V[J]&#39;</span>)
ax.plot(x, V)
fig.tight_layout()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="finding-the-minimum-for-circular-orbits">Finding the Minimum for Circular Orbits </h2>

<p>We take now the derivative of the effective potential in order to find its minimum, that is</p>
$$
\frac{dV_{\mathrm{eff}}(r)}{dr} = \beta-\frac{L^2}{\mu r^3}=0,
$$

<p>which gives us \( r_{\mathrm{min}} \)</p>

$$
r_{\mathrm{min}}=\left [\frac{L^2}{\beta \mu}\right ]^{1/3}.
$$

<p>With the above choice of parameters this gives \( r_{\mathrm{min}}=1 \). </p>

<p>In the code here we solve the equations of motion and find the time-evolution of the radius \( r \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="numerical-studies">Numerical Studies </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;">DeltaT = <span style="color: #B452CD">0.01</span>
<span style="color: #228B22">#set up arrays </span>
tfinal = <span style="color: #B452CD">8.0</span>
n = ceil(tfinal/DeltaT)
<span style="color: #228B22"># set up arrays for t, v and r</span>
t = np.zeros(n)
v = np.zeros(n)
r = np.zeros(n)
<span style="color: #228B22"># Constants of the model, setting all variables to one for simplicity</span>
beta = <span style="color: #B452CD">1.0</span>
AngMom = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22">#  The angular momentum</span>
m = <span style="color: #B452CD">1.0</span>  <span style="color: #228B22"># scale mass to one</span>
c1 = AngMom*AngMom/(m*m)
c2 = AngMom*AngMom/m
rmin = (AngMom*AngMom/m/beta)**(<span style="color: #B452CD">1.</span>/<span style="color: #B452CD">3.</span>)
<span style="color: #228B22"># Initial conditions, place yourself at the potential min</span>
r0 = rmin
v0 = <span style="color: #B452CD">0.0</span>  <span style="color: #228B22"># starts at rest</span>
r[<span style="color: #B452CD">0</span>] = r0
v[<span style="color: #B452CD">0</span>] = v0
<span style="color: #228B22"># Start integrating using the Velocity-Verlet  method</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n-<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># Set up acceleration</span>
    a = -beta+c1/(r[i]**<span style="color: #B452CD">3</span>)
    <span style="color: #228B22"># update velocity, time and position using the Velocity-Verlet method</span>
    r[i+<span style="color: #B452CD">1</span>] = r[i] + DeltaT*v[i]+<span style="color: #B452CD">0.5</span>*(DeltaT**<span style="color: #B452CD">2</span>)*a
    anew = -beta+c1/(r[i+<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">3</span>)
    v[i+<span style="color: #B452CD">1</span>] = v[i] + <span style="color: #B452CD">0.5</span>*DeltaT*(a+anew)
    t[i+<span style="color: #B452CD">1</span>] = t[i] + DeltaT
<span style="color: #228B22">#plotting</span>
plt.xlabel(<span style="color: #CD5555">&#39;time&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;radius&#39;</span>)
plt.plot(t,r)
save_fig(<span style="color: #CD5555">&quot;LinearPotential&quot;</span>)
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We see that if we run with the initial condition corresponding to a circular orbit, our radius stays constant as function of time. </p>

<!-- ------------------- end of main content --------------- -->
</body>
</html>

